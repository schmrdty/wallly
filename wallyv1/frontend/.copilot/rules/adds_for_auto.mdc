// Shared types for frontend and backend
export interface UserPermission {
  withdrawalAddress: string;
  allowEntireWallet: boolean;
  expiresAt: number;
  isActive: boolean;
  tokenList: string[];
  minBalances: string[];
  limits: string[];
}

export interface MiniAppSession {
  delegate: string;
  expiresAt: number;
  allowedTokens: string[];
  allowWholeWallet: boolean;
  active: boolean;
}

export interface AutomationConfig {
  id: string;
  type: AutomationType;
  walletAddress: string;
  enabled: boolean;
  createdAt: number;
  updatedAt: number;
  metadata: Record<string, any>;
}

export enum AutomationType {
  AUTO_SAVE = 'AUTO_SAVE',
  SUBSCRIPTION = 'SUBSCRIPTION',
  BILL_PAYMENT = 'BILL_PAYMENT',
  DCA_INVESTMENT = 'DCA_INVESTMENT',
  EMERGENCY_FUND = 'EMERGENCY_FUND',
  CHARITY_DONATION = 'CHARITY_DONATION',
  WALLET_CONSOLIDATION = 'WALLET_CONSOLIDATION'
}

export interface TransferRequest {
  wallet: string;
  token: string;
  recipient: string;
  amount: string;
}

updates to wallyService.ts
import { ethers } from 'ethers';
import { UserPermission, MiniAppSession, TransferRequest } from '../../shared/types.js';

export class WallyService {
  private watcherContract: ethers.Contract;
  private writerContract: ethers.Contract;
  private provider: ethers.Provider;
  private signer: ethers.Wallet;

  constructor(
    watcherAddress: string,
    writerAddress: string,
    watcherABI: any[],
    writerABI: any[],
    rpcUrl: string,
    privateKey: string
  ) {
    this.provider = new ethers.JsonRpcProvider(rpcUrl);
    this.signer = new ethers.Wallet(privateKey, this.provider);
    this.watcherContract = new ethers.Contract(watcherAddress, watcherABI, this.provider);
    this.writerContract = new ethers.Contract(writerAddress, writerABI, this.signer);
  }

  async getUserPermission(wallet: string): Promise<UserPermission> {
    const result = await this.watcherContract.getUserPermission(wallet);
    return {
      withdrawalAddress: result[0],
      allowEntireWallet: result[1],
      expiresAt: Number(result[2]),
      isActive: result[3],
      tokenList: result[4],
      minBalances: result[5].map((b: bigint) => b.toString()),
      limits: result[6].map((l: bigint) => l.toString())
    };
  }

  async getMiniAppSession(wallet: string): Promise<MiniAppSession> {
    const result = await this.watcherContract.getMiniAppSession(wallet);
    return {
      delegate: result[0],
      expiresAt: Number(result[1]),
      allowedTokens: result[2],
      allowWholeWallet: result[3],
      active: result[4]
    };
  }

  async executeTransfer(transfer: TransferRequest): Promise<ethers.TransactionResponse> {
    const tx = await this.writerContract.executeTransfer(
      transfer.wallet,
      transfer.token,
      transfer.recipient,
      transfer.amount
    );
    return tx;
  }

  async executeBatchTransfer(transfers: TransferRequest[]): Promise<ethers.TransactionResponse> {
    const wallets = transfers.map(t => t.wallet);
    const tokens = transfers.map(t => t.token);
    const recipients = transfers.map(t => t.recipient);
    const amounts = transfers.map(t => t.amount);

    const tx = await this.writerContract.executeBatchTransfer(
      wallets,
      tokens,
      recipients,
      amounts
    );
    return tx;
  }

  async validatePermissions(wallet: string): Promise<boolean> {
    try {
      const permission = await this.getUserPermission(wallet);
      const session = await this.getMiniAppSession(wallet);
      
      const now = Math.floor(Date.now() / 1000);
      return permission.isActive && 
             permission.expiresAt > now &&
             session.active &&
             session.expiresAt > now;
    } catch (error) {
      console.error('Permission validation error:', error);
      return false;
    }
  }
}

AUTO_SAVE Flow related:

import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';

interface AutoSaveConfig extends AutomationConfig {
  metadata: {
    thresholdAmount: string;
    targetSavingsAddress: string;
    tokenAddress: string;
    checkInterval: number; // in seconds
  };
}

export class AutoSaveAutomation {
  private wallyService: WallyService;
  private provider: ethers.Provider;
  private intervals: Map<string, NodeJS.Timeout> = new Map();

  constructor(wallyService: WallyService, provider: ethers.Provider) {
    this.wallyService = wallyService;
    this.provider = provider;
  }

  async start(config: AutoSaveConfig): Promise<void> {
    if (this.intervals.has(config.id)) {
      this.stop(config.id);
    }

    const interval = setInterval(async () => {
      try {
        await this.checkAndExecute(config);
      } catch (error) {
        console.error(`Auto-save error for ${config.id}:`, error);
      }
    }, config.metadata.checkInterval * 1000);

    this.intervals.set(config.id, interval);
  }

  stop(configId: string): void {
    const interval = this.intervals.get(configId);
    if (interval) {
      clearInterval(interval);
      this.intervals.delete(configId);
    }
  }

  private async checkAndExecute(config: AutoSaveConfig): Promise<void> {
    const { walletAddress, metadata } = config;
    const { thresholdAmount, targetSavingsAddress, tokenAddress } = metadata;

    // Validate permissions
    const hasPermission = await this.wallyService.validatePermissions(walletAddress);
    if (!hasPermission) {
      console.log(`No valid permission for wallet ${walletAddress}`);
      return;
    }

    // Check balance
    let balance: bigint;
    if (tokenAddress === ethers.ZeroAddress) {
      balance = await this.provider.getBalance(walletAddress);
    } else {
      const tokenContract = new ethers.Contract(
        tokenAddress,
        ['function balanceOf(address) view returns (uint256)'],
        this.provider
      );
      balance = await tokenContract.balanceOf(walletAddress);
    }

    const threshold = ethers.parseUnits(thresholdAmount, 18);
    
    if (balance > threshold) {
      const amountToSave = balance - threshold;
      
      const transfer: TransferRequest = {
        wallet: walletAddress,
        token: tokenAddress,
        recipient: targetSavingsAddress,
        amount: amountToSave.toString()
      };

      try {
        const tx = await this.wallyService.executeTransfer(transfer);
        console.log(`Auto-save executed: ${tx.hash}`);
        
        // Emit event or update database
        await this.logAutomationExecution(config.id, tx.hash, amountToSave.toString());
      } catch (error) {
        console.error('Auto-save transfer failed:', error);
      }
    }
  }

  private async logAutomationExecution(
    configId: string, 
    txHash: string, 
    amount: string
  ): Promise<void> {
    // Log to database
    console.log(`Automation ${configId} executed: ${txHash}, amount: ${amount}`);
  }
}

AUTO_SAVE Component:
import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';

interface AutoSaveFormData {
  thresholdAmount: string;
  targetSavingsAddress: string;
  tokenAddress: string;
  checkInterval: number;
}

export const AutoSaveComponent: React.FC = () => {
  const { address, signer } = useWallet();
  const [formData, setFormData] = useState<AutoSaveFormData>({
    thresholdAmount: '',
    targetSavingsAddress: '',
    tokenAddress: ethers.ZeroAddress,
    checkInterval: 3600 // 1 hour default
  });
  const [loading, setLoading] = useState(false);
  const [automations, setAutomations] = useState<AutomationConfig[]>([]);

  useEffect(() => {
    if (address) {
      fetchAutomations();
    }
  }, [address]);

  const fetchAutomations = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.AUTO_SAVE}`);
      const data = await response.json();
      setAutomations(data);
    } catch (error) {
      console.error('Failed to fetch automations:', error);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.AUTO_SAVE,
        walletAddress: address!,
        enabled: true,
        metadata: formData
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        await fetchAutomations();
        // Reset form
        setFormData({
          thresholdAmount: '',
          targetSavingsAddress: '',
          tokenAddress: ethers.ZeroAddress,
          checkInterval: 3600
        });
      }
    } catch (error) {
      console.error('Failed to create automation:', error);
    } finally {
      setLoading(false);
    }
  };

  const toggleAutomation = async (automationId: string, enabled: boolean) => {
    try {
      await fetch(`/api/automations/${automationId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled })
      });
      await fetchAutomations();
    } catch (error) {
      console.error('Failed to toggle automation:', error);
    }
  };

  return (
    <div className="auto-save-container">
      <h2>Auto-Save Configuration</h2>
      
      <form onSubmit={handleSubmit} className="auto-save-form">
        <div className="form-group">
          <label>Threshold Amount (ETH)</label>
          <input
            type="number"
            step="0.01"
            value={formData.thresholdAmount}
            onChange={(e) => setFormData({ ...formData, thresholdAmount: e.target.value })}
            required
          />
        </div>

        <div className="form-group">
          <label>Savings Wallet Address</label>
          <input
            type="text"
            value={formData.targetSavingsAddress}
            onChange={(e) => setFormData({ ...formData, targetSavingsAddress: e.target.value })}
            placeholder="0x..."
            required
          />
        </div>

        <div className="form-group">
          <label>Token Address (0x0 for ETH)</label>
          <input
            type="text"
            value={formData.tokenAddress}
            onChange={(e) => setFormData({ ...formData, tokenAddress: e.target.value })}
            placeholder="0x..."
          />
        </div>

        <div className="form-group">
          <label>Check Interval (seconds)</label>
          <select
            value={formData.checkInterval}
            onChange={(e) => setFormData({ ...formData, checkInterval: Number(e.target.value) })}
          >
            <option value={3600}>Every Hour</option>
            <option value={21600}>Every 6 Hours</option>
            <option value={86400}>Daily</option>
            <option value={604800}>Weekly</option>
          </select>
        </div>

        <button type="submit" disabled={loading || !address}>
          {loading ? 'Creating...' : 'Create Auto-Save'}
        </button>
      </form>

      <div className="automations-list">
        <h3>Active Auto-Saves</h3>
        {automations.map((automation) => (
          <div key={automation.id} className="automation-item">
            <div className="automation-details">
              <p>Threshold: {automation.metadata.thresholdAmount} ETH</p>
              <p>Target: {automation.metadata.targetSavingsAddress.slice(0, 10)}...</p>
              <p>Interval: {automation.metadata.checkInterval / 3600} hours</p>
            </div>
            <button
              onClick={() => toggleAutomation(automation.id, !automation.enabled)}
              className={automation.enabled ? 'disable-btn' : 'enable-btn'}
            >
              {automation.enabled ? 'Disable' : 'Enable'}
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};

SUBSCRIPTION Flow related:

import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';
import cron from 'node-cron';

interface SubscriptionConfig extends AutomationConfig {
  metadata: {
    serviceName: string;
    recipientAddress: string;
    amount: string;
    tokenAddress: string;
    frequency: 'monthly' | 'yearly';
    nextPaymentDate: number;
    dayOfMonth?: number;
    monthOfYear?: number;
  };
}

export class SubscriptionAutomation {
  private wallyService: WallyService;
  private cronJobs: Map<string, cron.ScheduledTask> = new Map();

  constructor(wallyService: WallyService) {
    this.wallyService = wallyService;
  }

  async start(config: SubscriptionConfig): Promise<void> {
    if (this.cronJobs.has(config.id)) {
      this.stop(config.id);
    }

    const cronExpression = this.getCronExpression(config.metadata);
    
    const task = cron.schedule(cronExpression, async () => {
      try {
        await this.processSubscriptionPayment(config);
      } catch (error) {
        console.error(`Subscription payment error for ${config.id}:`, error);
      }
    });

    task.start();
    this.cronJobs.set(config.id, task);
  }

  stop(configId: string): void {
    const job = this.cronJobs.get(configId);
    if (job) {
      job.stop();
      this.cronJobs.delete(configId);
    }
  }

  private getCronExpression(metadata: SubscriptionConfig['metadata']): string {
    if (metadata.frequency === 'monthly') {
      const day = metadata.dayOfMonth || 1;
      return `0 0 ${day} * *`; // At 00:00 on specified day every month
    } else {
      const month = metadata.monthOfYear || 1;
      const day = metadata.dayOfMonth || 1;
      return `0 0 ${day} ${month} *`; // At 00:00 on specified day and month every year
    }
  }

  private async processSubscriptionPayment(config: SubscriptionConfig): Promise<void> {
    const { walletAddress, metadata } = config;
    
    // Validate permissions
    const hasPermission = await this.wallyService.validatePermissions(walletAddress);
    if (!hasPermission) {
      await this.notifyPermissionExpired(config);
      return;
    }

    // Check balance before payment
    const hasBalance = await this.checkSufficientBalance(
      walletAddress,
      metadata.tokenAddress,
      metadata.amount
    );

    if (!hasBalance) {
      await this.notifyInsufficientBalance(config);
      return;
    }

    const transfer: TransferRequest = {
      wallet: walletAddress,
      token: metadata.tokenAddress,
      recipient: metadata.recipientAddress,
      amount: metadata.amount
    };

    try {
      const tx = await this.wallyService.executeTransfer(transfer);
      console.log(`Subscription payment executed: ${tx.hash}`);
      
      // Update next payment date
      await this.updateNextPaymentDate(config);
      
      // Send success notification
      await this.notifyPaymentSuccess(config, tx.hash);
    } catch (error) {
      console.error('Subscription payment failed:', error);
      await this.notifyPaymentFailed(config, error);
    }
  }

  private async checkSufficientBalance(
    wallet: string,
    token: string,
    amount: string
  ): Promise<boolean> {
    // Implementation to check token balance
    return true; // Simplified
  }

  private async updateNextPaymentDate(config: SubscriptionConfig): Promise<void> {
    const nextDate = new Date();
    if (config.metadata.frequency === 'monthly') {
      nextDate.setMonth(nextDate.getMonth() + 1);
    } else {
      nextDate.setFullYear(nextDate.getFullYear() + 1);
    }
    
    // Update in database
    config.metadata.nextPaymentDate = nextDate.getTime();
  }

  private async notifyPermissionExpired(config: SubscriptionConfig): Promise<void> {
    console.log(`Permission expired for subscription ${config.metadata.serviceName}`);
    // Send notification to user
  }

  private async notifyInsufficientBalance(config: SubscriptionConfig): Promise<void> {
    console.log(`Insufficient balance for subscription ${config.metadata.serviceName}`);
    // Send notification to user
  }

  private async notifyPaymentSuccess(config: SubscriptionConfig, txHash: string): Promise<void> {
    console.log(`Payment successful for ${config.metadata.serviceName}: ${txHash}`);
    // Send notification to user
  }

  private async notifyPaymentFailed(config: SubscriptionConfig, error: any): Promise<void> {
    console.error(`Payment failed for ${config.metadata.serviceName}:`, error);
    // Send notification to user
  }
}

SUBSCRIPTION Compoent:

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';

interface SubscriptionFormData {
  serviceName: string;
  recipientAddress: string;
  amount: string;
  tokenAddress: string;
  frequency: 'monthly' | 'yearly';
  dayOfMonth: number;
  monthOfYear?: number;
}

interface SubscriptionService {
  name: string;
  address: string;
  monthlyPrice: string;
  yearlyPrice: string;
  logo: string;
}

const POPULAR_SERVICES: SubscriptionService[] = [
  {
    name: 'Netflix',
    address: '0x1234...', // Replace with actual addresses
    monthlyPrice: '15.99',
    yearlyPrice: '159.99',
    logo: '/logos/netflix.png'
  },
  {
    name: 'Spotify',
    address: '0x5678...',
    monthlyPrice: '9.99',
    yearlyPrice: '99.99',
    logo: '/logos/spotify.png'
  }
];

export const SubscriptionManager: React.FC = () => {
  const { address } = useWallet();
  const [subscriptions, setSubscriptions] = useState<AutomationConfig[]>([]);
  const [showAddForm, setShowAddForm] = useState(false);
  const [selectedService, setSelectedService] = useState<SubscriptionService | null>(null);
  const [formData, setFormData] = useState<SubscriptionFormData>({
    serviceName: '',
    recipientAddress: '',
    amount: '',
    tokenAddress: ethers.ZeroAddress,
    frequency: 'monthly',
    dayOfMonth: 1
  });

  useEffect(() => {
    if (address) {
      fetchSubscriptions();
    }
  }, [address]);

  const fetchSubscriptions = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.SUBSCRIPTION}`);
      const data = await response.json();
      setSubscriptions(data);
    } catch (error) {
      console.error('Failed to fetch subscriptions:', error);
    }
  };

  const selectService = (service: SubscriptionService) => {
    setSelectedService(service);
    setFormData({
      ...formData,
      serviceName: service.name,
      recipientAddress: service.address,
      amount: formData.frequency === 'monthly' ? service.monthlyPrice : service.yearlyPrice
    });
  };

  const handleFrequencyChange = (frequency: 'monthly' | 'yearly') => {
    setFormData({
      ...formData,
      frequency,
      amount: selectedService 
        ? (frequency === 'monthly' ? selectedService.monthlyPrice : selectedService.yearlyPrice)
        : formData.amount
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.SUBSCRIPTION,
        walletAddress: address!,
        enabled: true,
        metadata: {
          ...formData,
          nextPaymentDate: calculateNextPaymentDate(formData.dayOfMonth, formData.frequency)
        }
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        await fetchSubscriptions();
        setShowAddForm(false);
        resetForm();
      }
    } catch (error) {
      console.error('Failed to create subscription:', error);
    }
  };

  const calculateNextPaymentDate = (day: number, frequency: 'monthly' | 'yearly'): number => {
    const date = new Date();
    date.setDate(day);
    
    if (date < new Date()) {
      if (frequency === 'monthly') {
        date.setMonth(date.getMonth() + 1);
      } else {
        date.setFullYear(date.getFullYear() + 1);
      }
    }
    
    return date.getTime();
  };

  const resetForm = () => {
    setFormData({
      serviceName: '',
      recipientAddress: '',
      amount: '',
      tokenAddress: ethers.ZeroAddress,
      frequency: 'monthly',
      dayOfMonth: 1
    });
    setSelectedService(null);
  };

  const cancelSubscription = async (subscriptionId: string) => {
    try {
      await fetch(`/api/automations/${subscriptionId}`, {
        method: 'DELETE'
      });
      await fetchSubscriptions();
    } catch (error) {
      console.error('Failed to cancel subscription:', error);
    }
  };

  return (
    <div className="subscription-manager">
      <div className="header">
        <h2>Subscription Manager</h2>
        <button 
          className="add-button"
          onClick={() => setShowAddForm(!showAddForm)}
        >
          {showAddForm ? 'Cancel' : 'Add Subscription'}
        </button>
      </div>

      {showAddForm && (
        <div className="add-subscription-form">
          <h3>Popular Services</h3>
          <div className="services-grid">
            {POPULAR_SERVICES.map((service) => (
              <div
                key={service.name}
                className={`service-card ${selectedService?.name === service.name ? 'selected' : ''}`}
                onClick={() => selectService(service)}
              >
                <img src={service.logo} alt={service.name} />
                <h4>{service.name}</h4>
                <p>${service.monthlyPrice}/mo</p>
              </div>
            ))}
          </div>

          <form onSubmit={handleSubmit}>
            <div className="form-group">
              <label>Service Name</label>
              <input
                type="text"
                value={formData.serviceName}
                onChange={(e) => setFormData({ ...formData, serviceName: e.target.value })}
                placeholder="Custom service name"
                required
              />
            </div>

            <div className="form-group">
              <label>Recipient Address</label>
              <input
                type="text"
                value={formData.recipientAddress}
                onChange={(e) => setFormData({ ...formData, recipientAddress: e.target.value })}
                placeholder="0x..."
                required
              />
            </div>

            <div className="form-group">
              <label>Payment Frequency</label>
              <div className="frequency-selector">
                <button
                  type="button"
                  className={formData.frequency === 'monthly' ? 'active' : ''}
                  onClick={() => handleFrequencyChange('monthly')}
                >
                  Monthly
                </button>
                <button
                  type="button"
                  className={formData.frequency === 'yearly' ? 'active' : ''}
                  onClick={() => handleFrequencyChange('yearly')}
                >
                  Yearly
                </button>
              </div>
            </div>

            <div className="form-group">
              <label>Amount (USDC)</label>
              <input
                type="number"
                step="0.01"
                value={formData.amount}
                onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
                required
              />
            </div>

            <div className="form-group">
              <label>Payment Day</label>
              <select
                value={formData.dayOfMonth}
                onChange={(e) => setFormData({ ...formData, dayOfMonth: Number(e.target.value) })}
              >
                {Array.from({ length: 28 }, (_, i) => i + 1).map(day => (
                  <option key={day} value={day}>{day}</option>
                ))}
              </select>
            </div>

            <button type="submit" className="submit-button">
              Add Subscription
            </button>
          </form>
        </div>
      )}

      <div className="subscriptions-list">
        <h3>Active Subscriptions</h3>
        {subscriptions.map((sub) => (
          <div key={sub.id} className="subscription-card">
            <div className="subscription-info">
              <h4>{sub.metadata.serviceName}</h4>
              <p className="amount">${sub.metadata.amount} {sub.metadata.frequency}</p>
              <p className="next-payment">
                Next payment: {new Date(sub.metadata.nextPaymentDate).toLocaleDateString()}
              </p>
            </div>
            <div className="subscription-actions">
              <button
                onClick={() => cancelSubscription(sub.id)}
                className="cancel-button"
              >
                Cancel
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

BILL_PAYMENT Flow related:

import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';

interface BillConfig extends AutomationConfig {
  metadata: {
    billType: 'electricity' | 'water' | 'gas' | 'internet' | 'phone' | 'other';
    providerName: string;
    accountNumber: string;
    recipientAddress: string;
    averageAmount: string;
    tokenAddress: string;
    dueDay: number;
    reminderDays: number; // Days before due date to send reminder
    autoPay: boolean;
  };
}

interface BillNotification {
  billId: string;
  amount: string;
  dueDate: number;
  status: 'pending' | 'paid' | 'overdue';
}

export class BillPaymentAutomation {
  private wallyService: WallyService;
  private pendingBills: Map<string, BillNotification> = new Map();

  constructor(wallyService: WallyService) {
    this.wallyService = wallyService;
    this.startDailyCheck();
  }

  private startDailyCheck(): void {
    // Run every day at 9 AM
    setInterval(async () => {
      const hour = new Date().getHours();
      if (hour === 9) {
        await this.checkAllBills();
      }
    }, 3600000); // Check every hour
  }

  async registerBill(config: BillConfig): Promise<void> {
    // Store bill configuration
    await this.saveBillConfig(config);
    
    // Check if bill is due soon
    await this.checkBillStatus(config);
  }

  private async checkAllBills(): Promise<void> {
    const bills = await this.getAllActiveBills();
    
    for (const bill of bills) {
      await this.checkBillStatus(bill);
    }
  }

  private async checkBillStatus(config: BillConfig): Promise<void> {
    const today = new Date();
    const dueDate = new Date();
    dueDate.setDate(config.metadata.dueDay);
    
    if (dueDate < today) {
      dueDate.setMonth(dueDate.getMonth() + 1);
    }
    
    const daysUntilDue = Math.floor((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
    
    // Send reminder if within reminder period
    if (daysUntilDue <= config.metadata.reminderDays && daysUntilDue > 0) {
      await this.sendBillReminder(config, daysUntilDue);
      
      // If auto-pay is enabled and it's the due date
      if (config.metadata.autoPay && daysUntilDue === 0) {
        await this.processAutomaticPayment(config);
      }
    }
    
    // Check for overdue bills
    if (daysUntilDue < 0) {
      await this.notifyOverdueBill(config);
    }
  }

  async processManualPayment(
    billId: string,
    amount: string,
    userAddress: string
  ): Promise<void> {
    const bill = this.pendingBills.get(billId);
    if (!bill) {
      throw new Error('Bill not found');
    }

    const config = await this.getBillConfig(billId);
    
    // Validate permissions
    const hasPermission = await this.wallyService.validatePermissions(userAddress);
    if (!hasPermission) {
      throw new Error('No valid permission');
    }

    const transfer: TransferRequest = {
      wallet: userAddress,
      token: config.metadata.tokenAddress,
      recipient: config.metadata.recipientAddress,
      amount: amount
    };

    try {
      const tx = await this.wallyService.executeTransfer(transfer);
      console.log(`Bill payment executed: ${tx.hash}`);
      
      // Update bill status
      bill.status = 'paid';
      this.pendingBills.set(billId, bill);
      
      // Store payment record
      await this.recordPayment(billId, amount, tx.hash);
      
      // Send confirmation
      await this.sendPaymentConfirmation(config, amount, tx.hash);
    } catch (error) {
      console.error('Bill payment failed:', error);
      throw error;
    }
  }

  private async processAutomaticPayment(config: BillConfig): Promise<void> {
    try {
      // Get current bill amount (could be from an oracle or API)
      const billAmount = await this.getCurrentBillAmount(config);
      
      const transfer: TransferRequest = {
        wallet: config.walletAddress,
        token: config.metadata.tokenAddress,
        recipient: config.metadata.recipientAddress,
        amount: billAmount
      };

      const tx = await this.wallyService.executeTransfer(transfer);
      console.log(`Auto bill payment executed: ${tx.hash}`);
      
      await this.recordPayment(config.id, billAmount, tx.hash);
      await this.sendPaymentConfirmation(config, billAmount, tx.hash);
    } catch (error) {
      console.error('Auto bill payment failed:', error);
      await this.notifyPaymentFailed(config, error);
    }
  }

  private async getCurrentBillAmount(config: BillConfig): Promise<string> {
    // In a real implementation, this would fetch from bill provider API
    // For now, return average amount
    return config.metadata.averageAmount;
  }

  private async sendBillReminder(config: BillConfig, daysUntilDue: number): Promise<void> {
    console.log(`Bill reminder: ${config.metadata.providerName} due in ${daysUntilDue} days`);
    // Send push notification, email, or in-app notification
  }

  private async notifyOverdueBill(config: BillConfig): Promise<void> {
    console.log(`OVERDUE: ${config.metadata.providerName} bill is overdue!`);
    // Send urgent notification
  }

  private async sendPaymentConfirmation(
    config: BillConfig, 
    amount: string, 
    txHash: string
  ): Promise<void> {
    console.log(`Payment confirmed: ${config.metadata.providerName}, Amount: ${amount}, TX: ${txHash}`);
    // Send confirmation notification
  }

  private async notifyPaymentFailed(config: BillConfig, error: any): Promise<void> {
    console.error(`Payment failed for ${config.metadata.providerName}:`, error);
    // Send failure notification
  }

  // Helper methods
  private async saveBillConfig(config: BillConfig): Promise<void> {
    // Save to database
  }

  private async getAllActiveBills(): Promise<BillConfig[]> {
    // Fetch from database
    return [];
  }

  private async getBillConfig(billId: string): Promise<BillConfig> {
    // Fetch from database
    throw new Error('Not implemented');
  }

  private async recordPayment(billId: string, amount: string, txHash: string): Promise<void> {
    // Record payment in database
  }
}

BILL_PAYMENT Component:

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { Calendar, AlertCircle, CheckCircle, Clock } from 'lucide-react';

interface Bill {
  id: string;
  type: string;
  providerName: string;
  amount: string;
  dueDate: Date;
  status: 'pending' | 'paid' | 'overdue';
  autoPay: boolean;
}

interface BillFormData {
  billType: string;
  providerName: string;
  accountNumber: string;
  recipientAddress: string;
  averageAmount: string;
  tokenAddress: string;
  dueDay: number;
  reminderDays: number;
  autoPay: boolean;
}

const BILL_TYPES = [
  { value: 'electricity', label: 'Electricity', icon: '⚡' },
  { value: 'water', label: 'Water', icon: '💧' },
  { value: 'gas', label: 'Gas', icon: '🔥' },
  { value: 'internet', label: 'Internet', icon: '🌐' },
  { value: 'phone', label: 'Phone', icon: '📱' },
  { value: 'other', label: 'Other', icon: '📄' }
];

export const BillPaymentComponent: React.FC = () => {
  const { address } = useWallet();
  const [bills, setBills] = useState<Bill[]>([]);
  const [billConfigs, setBillConfigs] = useState<AutomationConfig[]>([]);
  const [showAddForm, setShowAddForm] = useState(false);
  const [selectedBill, setSelectedBill] = useState<Bill | null>(null);
  const [paymentAmount, setPaymentAmount] = useState('');
  const [loading, setLoading] = useState(false);
  
  const [formData, setFormData] = useState<BillFormData>({
    billType: 'electricity',
    providerName: '',
    accountNumber: '',
    recipientAddress: '',
    averageAmount: '',
    tokenAddress: ethers.ZeroAddress,
    dueDay: 1,
    reminderDays: 3,
    autoPay: false
  });

  useEffect(() => {
    if (address) {
      fetchBills();
      fetchBillConfigs();
    }
  }, [address]);

  const fetchBills = async () => {
    try {
      const response = await fetch(`/api/bills/${address}/pending`);
      const data = await response.json();
      setBills(data);
    } catch (error) {
      console.error('Failed to fetch bills:', error);
    }
  };

  const fetchBillConfigs = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.BILL_PAYMENT}`);
      const data = await response.json();
      setBillConfigs(data);
    } catch (error) {
      console.error('Failed to fetch bill configs:', error);
    }
  };

  const handleAddBill = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.BILL_PAYMENT,
        walletAddress: address!,
        enabled: true,
        metadata: formData
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        await fetchBillConfigs();
        setShowAddForm(false);
        resetForm();
      }
    } catch (error) {
      console.error('Failed to add bill:', error);
    } finally {
      setLoading(false);
    }
  };

  const handlePayBill = async (bill: Bill) => {
    setLoading(true);

    try {
      const response = await fetch('/api/bills/pay', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          billId: bill.id,
          amount: paymentAmount || bill.amount,
          userAddress: address
        })
      });

      if (response.ok) {
        await fetchBills();
        setSelectedBill(null);
        setPaymentAmount('');
      }
    } catch (error) {
      console.error('Failed to pay bill:', error);
    } finally {
      setLoading(false);
    }
  };

  const toggleAutoPay = async (configId: string, enabled: boolean) => {
    try {
      await fetch(`/api/automations/${configId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ metadata: { autoPay: enabled } })
      });
      await fetchBillConfigs();
    } catch (error) {
      console.error('Failed to toggle auto-pay:', error);
    }
  };

  const resetForm = () => {
    setFormData({
      billType: 'electricity',
      providerName: '',
      accountNumber: '',
      recipientAddress: '',
      averageAmount: '',
      tokenAddress: ethers.ZeroAddress,
      dueDay: 1,
      reminderDays: 3,
      autoPay: false
    });
  };

  const getBillStatusIcon = (status: string) => {
    switch (status) {
      case 'paid':
        return <CheckCircle className="text-green-500" />;
      case 'overdue':
        return <AlertCircle className="text-red-500" />;
      default:
        return <Clock className="text-yellow-500" />;
    }
  };

  const getDaysUntilDue = (dueDate: Date) => {
    const today = new Date();
    const diffTime = dueDate.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
  };

  return (
    <div className="bill-payment-container">
      <div className="header">
        <h2>Bill Payment Manager</h2>
        <button
          className="add-button"
          onClick={() => setShowAddForm(!showAddForm)}
        >
          Add Bill
        </button>
      </div>

      {/* Upcoming Bills */}
      <div className="bills-section">
        <h3>Upcoming Bills</h3>
        <div className="bills-grid">
          {bills.map((bill) => {
            const daysUntilDue = getDaysUntilDue(bill.dueDate);
            return (
              <div key={bill.id} className={`bill-card ${bill.status}`}>
                <div className="bill-header">
                  <span className="bill-type-icon">
                    {BILL_TYPES.find(t => t.value === bill.type)?.icon}
                  </span>
                  <h4>{bill.providerName}</h4>
                  {getBillStatusIcon(bill.status)}
                </div>
                
                <div className="bill-details">
                  <div className="amount">
                    <span>Amount Due:</span>
                    <strong>${bill.amount}</strong>
                  </div>
                  
                  <div className="due-date">
                    <Calendar size={16} />
                    <span>{bill.dueDate.toLocaleDateString()}</span>
                    {bill.status === 'pending' && (
                      <span className={`days-until ${daysUntilDue <= 3 ? 'urgent' : ''}`}>
                        ({daysUntilDue} days)
                      </span>
                    )}
                  </div>
                </div>

                {bill.status === 'pending' && (
                  <div className="bill-actions">
                    <button
                      onClick={() => setSelectedBill(bill)}
                      className="pay-button"
                    >
                      Pay Now
                    </button>
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </div>

      {/* Bill Configurations */}
      <div className="configs-section">
        <h3>Bill Configurations</h3>
        <div className="configs-list">
          {billConfigs.map((config) => (
            <div key={config.id} className="config-item">
              <div className="config-info">
                <h4>{config.metadata.providerName}</h4>
                <p>Due: Day {config.metadata.dueDay} of each month</p>
                <p>Average: ${config.metadata.averageAmount}</p>
              </div>
              
              <div className="config-actions">
                <label className="auto-pay-toggle">
                  <input
                    type="checkbox"
                    checked={config.metadata.autoPay}
                    onChange={(e) => toggleAutoPay(config.id, e.target.checked)}
                  />
                  <span>Auto-pay</span>
                </label>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Add Bill Form */}
      {showAddForm && (
        <div className="modal-overlay" onClick={() => setShowAddForm(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <h3>Add New Bill</h3>
            <form onSubmit={handleAddBill}>
              <div className="form-group">
                <label>Bill Type</label>
                <select
                  value={formData.billType}
                  onChange={(e) => setFormData({ ...formData, billType: e.target.value })}
                >
                  {BILL_TYPES.map(type => (
                    <option key={type.value} value={type.value}>
                      {type.icon} {type.label}
                    </option>
                  ))}
                </select>
              </div>

              <div className="form-group">
                <label>Provider Name</label>
                <input
                  type="text"
                  value={formData.providerName}
                  onChange={(e) => setFormData({ ...formData, providerName: e.target.value })}
                  placeholder="e.g., City Electric Company"
                  required
                />
              </div>

              <div className="form-group">
                <label>Account Number</label>
                <input
                  type="text"
                  value={formData.accountNumber}
                  onChange={(e) => setFormData({ ...formData, accountNumber: e.target.value })}
                  placeholder="Your account number"
                  required
                />
              </div>

              <div className="form-group">
                <label>Payment Address</label>
                <input
                  type="text"
                  value={formData.recipientAddress}
                  onChange={(e) => setFormData({ ...formData, recipientAddress: e.target.value })}
                  placeholder="0x..."
                  required
                />
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label>Average Amount</label>
                  <input
                    type="number"
                    step="0.01"
                    value={formData.averageAmount}
                    onChange={(e) => setFormData({ ...formData, averageAmount: e.target.value })}
                    placeholder="0.00"
                    required
                  />
                </div>

                <div className="form-group">
                  <label>Due Day</label>
                  <select
                    value={formData.dueDay}
                    onChange={(e) => setFormData({ ...formData, dueDay: Number(e.target.value) })}
                  >
                    {Array.from({ length: 28 }, (_, i) => i + 1).map(day => (
                      <option key={day} value={day}>{day}</option>
                    ))}
                  </select>
                </div>
              </div>

              <div className="form-group">
                <label>Reminder Days Before Due</label>
                <input
                  type="number"
                  value={formData.reminderDays}
                  onChange={(e) => setFormData({ ...formData, reminderDays: Number(e.target.value) })}
                  min="1"
                  max="30"
                />
              </div>

              <div className="form-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.autoPay}
                    onChange={(e) => setFormData({ ...formData, autoPay: e.target.checked })}
                  />
                  <span>Enable Auto-pay</span>
                </label>
              </div>

              <div className="form-actions">
                <button type="button" onClick={() => setShowAddForm(false)}>
                  Cancel
                </button>
                <button type="submit" disabled={loading}>
                  {loading ? 'Adding...' : 'Add Bill'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Payment Modal */}
      {selectedBill && (
        <div className="modal-overlay" onClick={() => setSelectedBill(null)}>
          <div className="modal-content payment-modal" onClick={(e) => e.stopPropagation()}>
            <h3>Pay Bill</h3>
            <div className="payment-details">
              <p><strong>Provider:</strong> {selectedBill.providerName}</p>
              <p><strong>Due Date:</strong> {selectedBill.dueDate.toLocaleDateString()}</p>
              <p><strong>Amount Due:</strong> ${selectedBill.amount}</p>
            </div>

            <div className="form-group">
              <label>Payment Amount</label>
              <input
                type="number"
                step="0.01"
                value={paymentAmount || selectedBill.amount}
                onChange={(e) => setPaymentAmount(e.target.value)}
                placeholder={selectedBill.amount}
              />
            </div>

            <div className="form-actions">
              <button type="button" onClick={() => setSelectedBill(null)}>
                Cancel
              </button>
              <button 
                onClick={() => handlePayBill(selectedBill)}
                disabled={loading}
                className="pay-button"
              >
                {loading ? 'Processing...' : 'Pay Now'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

DCA_Investment Flow:

import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';

interface DCAConfig extends AutomationConfig {
  metadata: {
    strategyName: string;
    sourceToken: string;
    targetToken: string;
    amount: string;
    frequency: 'daily' | 'weekly' | 'biweekly' | 'monthly';
    exchangeAddress: string; // DEX router or exchange address
    slippageTolerance: number; // in basis points (100 = 1%)
    priceImpactLimit: number; // Maximum acceptable price impact
    startDate: number;
    endDate?: number;
    totalInvested: string;
    averagePrice: string;
    executionTimes: number[];
  };
}

interface PriceData {
  price: number;
  timestamp: number;
  source: string;
}

export class DCAAutomation {
  private wallyService: WallyService;
  private provider: ethers.Provider;
  private intervals: Map<string, NodeJS.Timeout> = new Map();
  private priceOracle: string; // Chainlink or other oracle address

  constructor(
    wallyService: WallyService, 
    provider: ethers.Provider,
    priceOracle: string
  ) {
    this.wallyService = wallyService;
    this.provider = provider;
    this.priceOracle = priceOracle;
  }

  async start(config: DCAConfig): Promise<void> {
    if (this.intervals.has(config.id)) {
      this.stop(config.id);
    }

    const intervalMs = this.getIntervalMs(config.metadata.frequency);
    
    // Execute immediately if it's time
    const shouldExecuteNow = await this.shouldExecute(config);
    if (shouldExecuteNow) {
      await this.executeDCA(config);
    }

    // Set up recurring execution
    const interval = setInterval(async () => {
      try {
        if (await this.shouldExecute(config)) {
          await this.executeDCA(config);
        }
      } catch (error) {
        console.error(`DCA error for ${config.id}:`, error);
      }
    }, intervalMs);

    this.intervals.set(config.id, interval);
  }

  stop(configId: string): void {
    const interval = this.intervals.get(configId);
    if (interval) {
      clearInterval(interval);
      this.intervals.delete(configId);
    }
  }

  private getIntervalMs(frequency: string): number {
    switch (frequency) {
      case 'daily':
        return 24 * 60 * 60 * 1000;
      case 'weekly':
        return 7 * 24 * 60 * 60 * 1000;
      case 'biweekly':
        return 14 * 24 * 60 * 60 * 1000;
      case 'monthly':
        return 30 * 24 * 60 * 60 * 1000;
      default:
        return 24 * 60 * 60 * 1000;
    }
  }

  private async shouldExecute(config: DCAConfig): Promise<boolean> {
    const now = Date.now();
    
    // Check if strategy has ended
    if (config.metadata.endDate && now > config.metadata.endDate) {
      this.stop(config.id);
      return false;
    }

    // Check if it's time to execute based on frequency
    const lastExecution = config.metadata.executionTimes[config.metadata.executionTimes.length - 1] || 0;
    const intervalMs = this.getIntervalMs(config.metadata.frequency);
    
    return now - lastExecution >= intervalMs;
  }

  private async executeDCA(config: DCAConfig): Promise<void> {
    const { walletAddress, metadata } = config;

    // Validate permissions
    const hasPermission = await this.wallyService.validatePermissions(walletAddress);
    if (!hasPermission) {
      console.log(`No valid permission for wallet ${walletAddress}`);
      return;
    }

    // Check balance
    const hasBalance = await this.checkSufficientBalance(
      walletAddress,
      metadata.sourceToken,
      metadata.amount
    );

    if (!hasBalance) {
      await this.notifyInsufficientBalance(config);
      return;
    }

    try {
      // Get current market price
      const priceData = await this.getCurrentPrice(
        metadata.sourceToken,
        metadata.targetToken
      );

      // Check price impact
      const priceImpact = await this.estimatePriceImpact(
        metadata.sourceToken,
        metadata.targetToken,
        metadata.amount
      );

      if (priceImpact > metadata.priceImpactLimit) {
        await this.notifyHighPriceImpact(config, priceImpact);
        return;
      }

      // Execute swap through DEX or transfer to exchange
      const swapData = await this.buildSwapTransaction(
        metadata.sourceToken,
        metadata.targetToken,
        metadata.amount,
        metadata.slippageTolerance
      );

      // If using a DEX, execute swap directly
      // If using CEX, just transfer to exchange address
      let tx: ethers.TransactionResponse;
      
      if (this.isDEX(metadata.exchangeAddress)) {
        // Execute DEX swap
        tx = await this.executeDEXSwap(walletAddress, swapData);
      } else {
        // Transfer to CEX
        const transfer: TransferRequest = {
          wallet: walletAddress,
          token: metadata.sourceToken,
          recipient: metadata.exchangeAddress,
          amount: metadata.amount
        };
        tx = await this.wallyService.executeTransfer(transfer);
      }

      console.log(`DCA executed: ${tx.hash}`);

      // Update DCA statistics
      await this.updateDCAStats(config, priceData.price, metadata.amount);
      
      // Record execution time
      config.metadata.executionTimes.push(Date.now());
      
      // Send notification
      await this.notifyDCAExecution(config, tx.hash, priceData);
    } catch (error) {
      console.error('DCA execution failed:', error);
      await this.notifyDCAFailed(config, error);
    }
  }

  private async getCurrentPrice(
    sourceToken: string,
    targetToken: string
  ): Promise<PriceData> {
    // Fetch price from oracle or DEX
    // Simplified implementation
    return {
      price: 2000, // Example: 1 ETH = 2000 USDC
      timestamp: Date.now(),
      source: 'Chainlink'
    };
  }

  private async estimatePriceImpact(
    sourceToken: string,
    targetToken: string,
    amount: string
  ): Promise<number> {
    // Calculate price impact based on liquidity
    // Simplified implementation
    return 0.5; // 0.5% price impact
  }

  private async buildSwapTransaction(
    sourceToken: string,
    targetToken: string,
    amount: string,
    slippageTolerance: number
  ): Promise<any> {
    // Build swap transaction data for DEX
    // This would integrate with Uniswap, Sushiswap, etc.
    return {
      to: '0x...', // DEX router
      data: '0x...', // Encoded swap data
      value: sourceToken === ethers.ZeroAddress ? amount : '0'
    };
  }

  private isDEX(address: string): boolean {
    // Check if address is a known DEX router
    const knownDEXs = [
      '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D', // Uniswap V2
      '0xE592427A0AEce92De3Edee1F18E0157C05861564', // Uniswap V3
      // Add more DEX routers
    ];
    return knownDEXs.includes(address.toLowerCase());
  }

  private async executeDEXSwap(
    walletAddress: string,
    swapData: any
  ): Promise<ethers.TransactionResponse> {
    // Execute swap through DEX
    // This would be implemented based on specific DEX integration
    throw new Error('DEX integration not implemented');
  }

  private async updateDCAStats(
    config: DCAConfig,
    currentPrice: number,
    amount: string
  ): Promise<void> {
    const amountNumber = parseFloat(ethers.formatUnits(amount, 18));
    const totalInvested = parseFloat(config.metadata.totalInvested) + amountNumber;
    const totalExecutions = config.metadata.executionTimes.length + 1;
    
    // Calculate new average price
    const newAveragePrice = totalInvested / totalExecutions;
    
    config.metadata.totalInvested = totalInvested.toString();
    config.metadata.averagePrice = newAveragePrice.toString();
    
    // Save updated config
    await this.saveConfig(config);
  }

  private async checkSufficientBalance(
    wallet: string,
    token: string,
    amount: string
  ): Promise<boolean> {
    try {
      let balance: bigint;
      if (token === ethers.ZeroAddress) {
        balance = await this.provider.getBalance(wallet);
      } else {
        const tokenContract = new ethers.Contract(
          token,
          ['function balanceOf(address) view returns (uint256)'],
          this.provider
        );
        balance = await tokenContract.balanceOf(wallet);
      }
      
      return balance >= BigInt(amount);
    } catch (error) {
      console.error('Balance check failed:', error);
      return false;
    }
  }

  DCA_Investment Component:

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { TrendingUp, Calendar, DollarSign, BarChart3, AlertCircle } from 'lucide-react';

interface DCAFormData {
  strategyName: string;
  sourceToken: string;
  targetToken: string;
  amount: string;
  frequency: 'daily' | 'weekly' | 'biweekly' | 'monthly';
  exchangeAddress: string;
  slippageTolerance: number;
  priceImpactLimit: number;
  startDate: string;
  endDate?: string;
}

interface DCAStrategy {
  id: string;
  name: string;
  sourceToken: { symbol: string; address: string };
  targetToken: { symbol: string; address: string };
  amount: string;
  frequency: string;
  totalInvested: string;
  averagePrice: string;
  executionCount: number;
  nextExecution: Date;
  performance: number; // percentage gain/loss
}

const POPULAR_TOKENS = [
  { symbol: 'ETH', address: ethers.ZeroAddress, name: 'Ethereum' },
  { symbol: 'USDC', address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', name: 'USD Coin' },
  { symbol: 'WBTC', address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', name: 'Wrapped Bitcoin' },
  { symbol: 'DAI', address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', name: 'Dai' }
];

const EXCHANGES = [
  { name: 'Uniswap V3', address: '0xE592427A0AEce92De3Edee1F18E0157C05861564', type: 'dex' },
  { name: 'SushiSwap', address: '0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F', type: 'dex' },
  { name: 'Binance Hot Wallet', address: '0x28C6c06298d514Db089934071355E5743bf21d60', type: 'cex' },
  { name: 'Coinbase Commerce', address: '0x881D40237659C251811CEC9c364ef91dC08D300C', type: 'cex' }
];

export const InvestmentDCAComponent: React.FC = () => {
  const { address } = useWallet();
  const [strategies, setStrategies] = useState<DCAStrategy[]>([]);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [selectedStrategy, setSelectedStrategy] = useState<DCAStrategy | null>(null);
  const [loading, setLoading] = useState(false);
  
  const [formData, setFormData] = useState<DCAFormData>({
    strategyName: '',
    sourceToken: POPULAR_TOKENS[1].address, // USDC default
    targetToken: POPULAR_TOKENS[0].address, // ETH default
    amount: '',
    frequency: 'weekly',
    exchangeAddress: EXCHANGES[0].address,
    slippageTolerance: 100, // 1%
    priceImpactLimit: 200, // 2%
    startDate: new Date().toISOString().split('T')[0],
    endDate: ''
  });

  useEffect(() => {
    if (address) {
      fetchStrategies();
    }
  }, [address]);

  const fetchStrategies = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.DCA_INVESTMENT}`);
      const configs = await response.json();
      
      // Transform configs to strategies for display
      const strategiesData = configs.map((config: AutomationConfig) => ({
        id: config.id,
        name: config.metadata.strategyName,
        sourceToken: POPULAR_TOKENS.find(t => t.address === config.metadata.sourceToken) || { symbol: 'UNKNOWN', address: config.metadata.sourceToken },
        targetToken: POPULAR_TOKENS.find(t => t.address === config.metadata.targetToken) || { symbol: 'UNKNOWN', address: config.metadata.targetToken },
        amount: config.metadata.amount,
        frequency: config.metadata.frequency,
        totalInvested: config.metadata.totalInvested || '0',
        averagePrice: config.metadata.averagePrice || '0',
        executionCount: config.metadata.executionTimes?.length || 0,
        nextExecution: calculateNextExecution(config.metadata),
        performance: calculatePerformance(config.metadata)
      }));
      
      setStrategies(strategiesData);
    } catch (error) {
      console.error('Failed to fetch strategies:', error);
    }
  };

  const calculateNextExecution = (metadata: any): Date => {
    const lastExecution = metadata.executionTimes?.[metadata.executionTimes.length - 1];
    if (!lastExecution) return new Date(metadata.startDate);
    
    const intervalDays = {
      daily: 1,
      weekly: 7,
      biweekly: 14,
      monthly: 30
    };
    
    const nextDate = new Date(lastExecution);
    nextDate.setDate(nextDate.getDate() + intervalDays[metadata.frequency]);
    return nextDate;
  };

  const calculatePerformance = (metadata: any): number => {
    // Simplified calculation - would need current price data
    if (!metadata.averagePrice || metadata.averagePrice === '0') return 0;
    const currentPrice = 2000; // Mock current price
    return ((currentPrice - parseFloat(metadata.averagePrice)) / parseFloat(metadata.averagePrice)) * 100;
  };

  const handleCreateStrategy = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.DCA_INVESTMENT,
        walletAddress: address!,
        enabled: true,
        metadata: {
          ...formData,
          totalInvested: '0',
          averagePrice: '0',
          executionTimes: []
        }
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        await fetchStrategies();
        setShowCreateForm(false);
        resetForm();
      }
    } catch (error) {
      console.error('Failed to create DCA strategy:', error);
    } finally {
      setLoading(false);
    }
  };

  const toggleStrategy = async (strategyId: string, enabled: boolean) => {
    try {
      await fetch(`/api/automations/${strategyId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled })
      });
      await fetchStrategies();
    } catch (error) {
      console.error('Failed to toggle strategy:', error);
    }
  };

  const deleteStrategy = async (strategyId: string) => {
    if (!confirm('Are you sure you want to delete this strategy?')) return;
    
    try {
      await fetch(`/api/automations/${strategyId}`, {
        method: 'DELETE'
      });
      await fetchStrategies();
    } catch (error) {
      console.error('Failed to delete strategy:', error);
    }
  };

  const resetForm = () => {
    setFormData({
      strategyName: '',
      sourceToken: POPULAR_TOKENS[1].address,
      targetToken: POPULAR_TOKENS[0].address,
      amount: '',
      frequency: 'weekly',
      exchangeAddress: EXCHANGES[0].address,
      slippageTolerance: 100,
      priceImpactLimit: 200,
      startDate: new Date().toISOString().split('T')[0],
      endDate: ''
    });
  };

  const getFrequencyLabel = (frequency: string): string => {
    const labels = {
      daily: 'Daily',
      weekly: 'Weekly',
      biweekly: 'Bi-weekly',
      monthly: 'Monthly'
    };
    return labels[frequency] || frequency;
  };

  const formatAmount = (amount: string, decimals: number = 2): string => {
    try {
      return parseFloat(ethers.formatUnits(amount, 18)).toFixed(decimals);
    } catch {
      return amount;
    }
  };

  return (
    <div className="dca-investment-container">
      <div className="header">
        <h2>DCA Investment Strategies</h2>
        <button
          className="create-button"
          onClick={() => setShowCreateForm(!showCreateForm)}
        >
          <TrendingUp size={20} />
          New Strategy
        </button>
      </div>

      {/* Active Strategies */}
      <div className="strategies-grid">
        {strategies.map((strategy) => (
          <div key={strategy.id} className="strategy-card">
            <div className="strategy-header">
              <h3>{strategy.name}</h3>
              <div className={`performance ${strategy.performance >= 0 ? 'positive' : 'negative'}`}>
                {strategy.performance >= 0 ? '+' : ''}{strategy.performance.toFixed(2)}%
              </div>
            </div>

            <div className="strategy-details">
              <div className="detail-row">
                <span className="label">Investment:</span>
                <span className="value">
                  {formatAmount(strategy.amount)} {strategy.sourceToken.symbol} → {strategy.targetToken.symbol}
                </span>
              </div>

              <div className="detail-row">
                <span className="label">Frequency:</span>
                <span className="value">{getFrequencyLabel(strategy.frequency)}</span>
              </div>

              <div className="detail-row">
                <span className="label">Total Invested:</span>
                <span className="value">${formatAmount(strategy.totalInvested)}</span>
              </div>

              <div className="detail-row">
                <span className="label">Avg. Price:</span>
                <span className="value">${formatAmount(strategy.averagePrice)}</span>
              </div>

              <div className="detail-row">
                <span className="label">Executions:</span>
                <span className="value">{strategy.executionCount}</span>
              </div>

              <div className="detail-row">
                <span className="label">Next Buy:</span>
                <span className="value">{strategy.nextExecution.toLocaleDateString()}</span>
              </div>
            </div>

            <div className="strategy-actions">
              <button
                onClick={() => setSelectedStrategy(strategy)}
                className="details-button"
              >
                <BarChart3 size={16} />
                Details
              </button>
              <button
                onClick={() => toggleStrategy(strategy.id, false)}
                className="pause-button"
              >
                Pause
              </button>
              <button
                onClick={() => deleteStrategy(strategy.id)}
                className="delete-button"
              >
                Delete
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Create Strategy Form */}
      {showCreateForm && (
        <div className="modal-overlay" onClick={() => setShowCreateForm(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <h3>Create DCA Strategy</h3>
            
            <form onSubmit={handleCreateStrategy}>
              <div className="form-group">
                <label>Strategy Name</label>
                <input
                  type="text"
                  value={formData.strategyName}
                  onChange={(e) => setFormData({ ...formData, strategyName: e.target.value })}
                  placeholder="e.g., ETH Accumulation"
                  required
                />
              </div>

              <div className="token-selection">
                <div className="form-group">
                  <label>From Token</label>
                  <select
                    value={formData.sourceToken}
                    onChange={(e) => setFormData({ ...formData, sourceToken: e.target.value })}
                  >
                    {POPULAR_TOKENS.map(token => (
                      <option key={token.address} value={token.address}>
                        {token.symbol} - {token.name}
                      </option>
                    ))}
                  </select>
                </div>

                <div className="swap-arrow">→</div>

                <div className="form-group">
                  <label>To Token</label>
                  <select
                    value={formData.targetToken}
                    onChange={(e) => setFormData({ ...formData, targetToken: e.target.value })}
                  >
                    {POPULAR_TOKENS.map(token => (
                      <option key={token.address} value={token.address}>
                        {token.symbol} - {token.name}
                      </option>
                    ))}
                  </select>
                </div>
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label>Amount per Purchase</label>
                  <input
                    type="number"
                    step="0.01"
                    value={formData.amount}
                    onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
                    placeholder="100"
                    required
                  />
                </div>

                <div className="form-group">
                  <label>Frequency</label>
                  <select
                    value={formData.frequency}
                    onChange={(e) => setFormData({ ...formData, frequency: e.target.value as any })}
                  >
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly</option>
                    <option value="biweekly">Bi-weekly</option>
                    <option value="monthly">Monthly</option>
                  </select>
                </div>
              </div>

              <div className="form-group">
                <label>Exchange/DEX</label>
                <select
                  value={formData.exchangeAddress}
                  onChange={(e) => setFormData({ ...formData, exchangeAddress: e.target.value })}
                >
                  {EXCHANGES.map(exchange => (
                    <option key={exchange.address} value={exchange.address}>
                      {exchange.name} ({exchange.type.toUpperCase()})
                    </option>
                  ))}
                </select>
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label>Slippage Tolerance (%)</label>
                  <input
                    type="number"
                    step="0.1"
                    value={formData.slippageTolerance / 100}
                    onChange={(e) => setFormData({ ...formData, slippageTolerance: parseFloat(e.target.value) * 100 })}
                    min="0.1"
                    max="5"
                  />
                </div>

                <div className="form-group">
                  <label>Max Price Impact (%)</label>
                  <input
                    type="number"
                    step="0.1"
                    value={formData.priceImpactLimit / 100}
                    onChange={(e) => setFormData({ ...formData, priceImpactLimit: parseFloat(e.target.value) * 100 })}
                    min="0.1"
                    max="10"
                  />
                </div>
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label>Start Date</label>
                  <input
                    type="date"
                    value={formData.startDate}
                    onChange={(e) => setFormData({ ...formData, startDate: e.target.value })}
                    min={new Date().toISOString().split('T')[0]}
                    required
                  />
                </div>

                <div className="form-group">
                  <label>End Date (Optional)</label>
                  <input
                    type="date"
                    value={formData.endDate}
                    onChange={(e) => setFormData({ ...formData, endDate: e.target.value })}
                    min={formData.startDate}
                  />
                </div>
              </div>

              <div className="warning-box">
                <AlertCircle size={16} />
                <p>
                  DCA strategies involve market risk. Past performance does not guarantee future results.
                </p>
              </div>

              <div className="form-actions">
                <button type="button" onClick={() => setShowCreateForm(false)}>
                  Cancel
                </button>
                <button type="submit" disabled={loading}>
                  {loading ? 'Creating...' : 'Create Strategy'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Strategy Details Modal */}
      {selectedStrategy && (
        <div className="modal-overlay" onClick={() => setSelectedStrategy(null)}>
          <div className="modal-content strategy-details" onClick={(e) => e.stopPropagation()}>
            <h3>{selectedStrategy.name} Performance</h3>
            
            <div className="performance-chart">
              {/* Chart would go here - using placeholder */}
              <div className="chart-placeholder">
                <BarChart3 size={48} />
                <p>Performance chart coming soon</p>
              </div>
            </div>

            <div className="performance-stats">
              <div className="stat">
                <label>Total Invested</label>
                <value>${formatAmount(selectedStrategy.totalInvested)}</value>
              </div>
              <div className="stat">
                <label>Current Value</label>
                <value>$--</value>
              </div>
              <div className="stat">
                <label>Profit/Loss</label>
                <value className={selectedStrategy.performance >= 0 ? 'positive' : 'negative'}>
                  {selectedStrategy.performance >= 0 ? '+' : ''}{selectedStrategy.performance.toFixed(2)}%
                </value>
              </div>
              <div className="stat">
                <label>Next Purchase</label>
                <value>{selectedStrategy.nextExecution.toLocaleString()}</value>
              </div>
            </div>

            <button onClick={() => setSelectedStrategy(null)}>Close</button>
          </div>
        </div>
      )}
    </div>
  );
};

EMERGENCY_FUND Flow:

import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';

interface EmergencyFundConfig extends AutomationConfig {
  metadata: {
    fundName: string;
    targetAmount: string;
    currentAmount: string;
    minThreshold: string;
    tokenAddress: string;
    fundAddress: string;
    autoTopUp: boolean;
    topUpAmount: string;
    checkInterval: number;
    notificationThreshold: number; // Percentage of min threshold to trigger notification
    lastChecked: number;
    history: FundEvent[];
  };
}

interface FundEvent {
  type: 'deposit' | 'withdrawal' | 'auto-topup';
  amount: string;
  timestamp: number;
  txHash: string;
  balance: string;
}

export class EmergencyFundAutomation {
  private wallyService: WallyService;
  private provider: ethers.Provider;
  private intervals: Map<string, NodeJS.Timeout> = new Map();

  constructor(wallyService: WallyService, provider: ethers.Provider) {
    this.wallyService = wallyService;
    this.provider = provider;
  }

  async start(config: EmergencyFundConfig): Promise<void> {
    if (this.intervals.has(config.id)) {
      this.stop(config.id);
    }

    // Initial check
    await this.checkFundStatus(config);

    // Set up periodic monitoring
    const interval = setInterval(async () => {
      try {
        await this.checkFundStatus(config);
      } catch (error) {
        console.error(`Emergency fund check error for ${config.id}:`, error);
      }
    }, config.metadata.checkInterval * 1000);

    this.intervals.set(config.id, interval);
  }

  stop(configId: string): void {
    const interval = this.intervals.get(configId);
    if (interval) {
      clearInterval(interval);
      this.intervals.delete(configId);
    }
  }

  private async checkFundStatus(config: EmergencyFundConfig): Promise<void> {
    const { fundAddress, tokenAddress, minThreshold, autoTopUp } = config.metadata;

    // Get current balance
    let currentBalance: bigint;
    if (tokenAddress === ethers.ZeroAddress) {
      currentBalance = await this.provider.getBalance(fundAddress);
    } else {
      const tokenContract = new ethers.Contract(
        tokenAddress,
        ['function balanceOf(address) view returns (uint256)'],
        this.provider
      );
      currentBalance = await tokenContract.balanceOf(fundAddress);
    }

    // Update current amount
    config.metadata.currentAmount = currentBalance.toString();
    config.metadata.lastChecked = Date.now();

    const threshold = BigInt(minThreshold);
    const notificationLevel = (threshold * BigInt(config.metadata.notificationThreshold)) / BigInt(100);

    // Check if below minimum threshold
    if (currentBalance < threshold) {
      await this.notifyLowBalance(config, currentBalance, threshold);

      if (autoTopUp) {
        await this.executeTopUp(config, currentBalance, threshold);
      }
    } else if (currentBalance < notificationLevel) {
      // Warning notification
      await this.notifyApproachingThreshold(config, currentBalance, threshold);
    }

    // Save updated config
    await this.updateConfig(config);
  }

  private async executeTopUp(
    config: EmergencyFundConfig,
    currentBalance: bigint,
    threshold: bigint
  ): Promise<void> {
    const { walletAddress, metadata } = config;
    const { tokenAddress, fundAddress, topUpAmount } = metadata;

    // Validate permissions
    const hasPermission = await this.wallyService.validatePermissions(walletAddress);
    if (!hasPermission) {
      console.log(`No valid permission for emergency fund top-up: ${walletAddress}`);
      return;
    }

    // Calculate amount needed
    const amountNeeded = threshold - currentBalance;
    const topUp = BigInt(topUpAmount);
    const amountToTransfer = amountNeeded > topUp ? topUp : amountNeeded;

    // Check if source wallet has sufficient balance
    const hasBalance = await this.checkSufficientBalance(
      walletAddress,
      tokenAddress,
      amountToTransfer.toString()
    );

    if (!hasBalance) {
      await this.notifyInsufficientSourceBalance(config);
      return;
    }

    const transfer: TransferRequest = {
      wallet: walletAddress,
      token: tokenAddress,
      recipient: fundAddress,
      amount: amountToTransfer.toString()
    };

    try {
      const tx = await this.wallyService.executeTransfer(transfer);
      console.log(`Emergency fund top-up executed: ${tx.hash}`);

      // Record event
      const event: FundEvent = {
        type: 'auto-topup',
        amount: amountToTransfer.toString(),
        timestamp: Date.now(),
        txHash: tx.hash,
        balance: (currentBalance + amountToTransfer).toString()
      };

      config.metadata.history.push(event);
      config.metadata.currentAmount = (currentBalance + amountToTransfer).toString();

      await this.notifyTopUpSuccess(config, amountToTransfer.toString(), tx.hash);
    } catch (error) {
      console.error('Emergency fund top-up failed:', error);
      await this.notifyTopUpFailed(config, error);
    }
  }

  async manualDeposit(
    configId: string,
    amount: string,
    userAddress: string
  ): Promise<void> {
    const config = await this.getConfig(configId);
    const { tokenAddress, fundAddress } = config.metadata;

    const transfer: TransferRequest = {
      wallet: userAddress,
      token: tokenAddress,
      recipient: fundAddress,
      amount
    };

    try {
      const tx = await this.wallyService.executeTransfer(transfer);
      
      // Update balance and record event
      const currentBalance = BigInt(config.metadata.currentAmount);
      const newBalance = currentBalance + BigInt(amount);
      
      const event: FundEvent = {
        type: 'deposit',
        amount,
        timestamp: Date.now(),
        txHash: tx.hash,
        balance: newBalance.toString()
      };

      config.metadata.history.push(event);
      config.metadata.currentAmount = newBalance.toString();
      
      await this.updateConfig(config);
      await this.notifyDepositSuccess(config, amount, tx.hash);
    } catch (error) {
      console.error('Manual deposit failed:', error);
      throw error;
    }
  }

  async emergencyWithdraw(
    configId: string,
    amount: string,
    reason: string,
    userAddress: string
  ): Promise<void> {
    const config = await this.getConfig(configId);
    
    // This would require additional logic to withdraw from the fund
    // For now, we'll log the request
    console.log(`Emergency withdrawal requested: ${amount} for ${reason}`);
    
    // In a real implementation, this would:
    // 1. Verify user authorization
    // 2. Execute withdrawal from fund to user
    // 3. Record the withdrawal event
    // 4. Send notifications
  }

  private async checkSufficientBalance(
    wallet: string,
    token: string,
    amount: string
  ): Promise<boolean> {
    try {
      let balance: bigint;
      if (token === ethers.ZeroAddress) {
        balance = await this.provider.getBalance(wallet);
      } else {
        const tokenContract = new ethers.Contract(
          token,
          ['function balanceOf(address) view returns (uint256)'],
          this.provider
        );
        balance = await tokenContract.balanceOf(wallet);
      }
      
      return balance >= BigInt(amount);
    } catch (error) {
      console.error('Balance check failed:', error);
      return false;
    }
  }

  // Notification methods
  private async notifyLowBalance(
    config: EmergencyFundConfig,
    currentBalance: bigint,
    threshold: bigint
  ): Promise<void> {
    const percentageRemaining = (Number(currentBalance) / Number(threshold)) * 100;
    console.log(`⚠️ Emergency fund LOW: ${config.metadata.fundName} at ${percentageRemaining.toFixed(1)}% of minimum`);
  }

  private async notifyApproachingThreshold(
    config: EmergencyFundConfig,
    currentBalance: bigint,
    threshold: bigint
  ): Promise<void> {
    const percentageRemaining = (Number(currentBalance) / Number(threshold)) * 100;
    console.log(`📊 Emergency fund warning: ${config.metadata.fundName} at ${percentageRemaining.toFixed(1)}% of minimum`);
  }

  private async notifyTopUpSuccess(
    config: EmergencyFundConfig,
    amount: string,
    txHash: string
  ): Promise<void> {
    console.log(`✅ Emergency fund topped up: ${amount} added to ${config.metadata.fundName}`);
  }

  private async notifyTopUpFailed(config: EmergencyFundConfig, error: any): Promise<void> {
    console.error(`❌ Emergency fund top-up failed for ${config.metadata.fundName}:`, error);
  }

  private async notifyInsufficientSourceBalance(config: EmergencyFundConfig): Promise<void> {
    console.log(`💸 Insufficient balance to top up emergency fund: ${config.metadata.fundName}`);
  }

  private async notifyDepositSuccess(
    config: EmergencyFundConfig,
    amount: string,
    txHash: string
  ): Promise<void> {
    console.log(`✅ Manual deposit successful: ${amount} added to ${config.metadata.fundName}`);
  }

  // Helper methods
  private async getConfig(configId: string): Promise<EmergencyFundConfig> {
    // Fetch from database
    throw new Error('Not implemented');
  }

  private async updateConfig(config: EmergencyFundConfig): Promise<void> {
    // Update in database
  }
}

EMERGENCY_FUND Component:

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { Shield, AlertTriangle, TrendingUp, Plus, Minus, History } from 'lucide-react';

interface EmergencyFundFormData {
  fundName: string;
  targetAmount: string;
  minThreshold: string;
  tokenAddress: string;
  fundAddress: string;
  autoTopUp: boolean;
  topUpAmount: string;
  checkInterval: number;
  notificationThreshold: number;
}

interface FundStatus {
  id: string;
  name: string;
  currentAmount: string;
  targetAmount: string;
  minThreshold: string;
  percentage: number;
  status: 'healthy' | 'warning' | 'critical';
  autoTopUp: boolean;
  lastChecked: Date;
  history: any[];
}

export const EmergencyFundComponent: React.FC = () => {
  const { address } = useWallet();
  const [funds, setFunds] = useState<FundStatus[]>([]);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [selectedFund, setSelectedFund] = useState<FundStatus | null>(null);
  const [depositAmount, setDepositAmount] = useState('');
  const [withdrawAmount, setWithdrawAmount] = useState('');
  const [withdrawReason, setWithdrawReason] = useState('');
  const [loading, setLoading] = useState(false);
  
  const [formData, setFormData] = useState<EmergencyFundFormData>({
    fundName: '',
    targetAmount: '',
    minThreshold: '',
    tokenAddress: ethers.ZeroAddress,
    fundAddress: '',
    autoTopUp: true,
    topUpAmount: '',
    checkInterval: 86400, // Daily
    notificationThreshold: 80 // Alert at 80% of minimum
  });

  useEffect(() => {
    if (address) {
      fetchFunds();
    }
  }, [address]);

  const fetchFunds = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.EMERGENCY_FUND}`);
      const configs = await response.json();
      
      const fundsData = configs.map((config: AutomationConfig) => {
        const currentAmount = parseFloat(ethers.formatUnits(config.metadata.currentAmount || '0', 18));
        const targetAmount = parseFloat(ethers.formatUnits(config.metadata.targetAmount, 18));
        const minThreshold = parseFloat(ethers.formatUnits(config.metadata.minThreshold, 18));
        
        const percentage = (currentAmount / targetAmount) * 100;
        let status: 'healthy' | 'warning' | 'critical' = 'healthy';
        
        if (currentAmount < minThreshold) {
          status = 'critical';
        } else if (currentAmount < minThreshold * 1.2) {
          status = 'warning';
        }
        
        return {
          id: config.id,
          name: config.metadata.fundName,
          currentAmount: currentAmount.toFixed(2),
          targetAmount: targetAmount.toFixed(2),
          minThreshold: minThreshold.toFixed(2),
          percentage,
          status,
          autoTopUp: config.metadata.autoTopUp,
          lastChecked: new Date(config.metadata.lastChecked || Date.now()),
          history: config.metadata.history || []
        };
      });
      
      setFunds(fundsData);
    } catch (error) {
      console.error('Failed to fetch emergency funds:', error);
    }
  };

  const handleCreateFund = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.EMERGENCY_FUND,
        walletAddress: address!,
        enabled: true,
        metadata: {
          ...formData,
          currentAmount: '0',
          lastChecked: Date.now(),
          history: []
        }
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        await fetchFunds();
        setShowCreateForm(false);
        resetForm();
      }
    } catch (error) {
      console.error('Failed to create emergency fund:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleDeposit = async (fundId: string) => {
    setLoading(true);

    try {
      const response = await fetch(`/api/emergency-fund/${fundId}/deposit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          amount: ethers.parseUnits(depositAmount, 18).toString(),
          userAddress: address
        })
      });

      if (response.ok) {
        await fetchFunds();
        setDepositAmount('');
        setSelectedFund(null);
      }
    } catch (error) {
      console.error('Failed to deposit:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleWithdraw = async (fundId: string) => {
    if (!withdrawReason.trim()) {
      alert('Please provide a reason for withdrawal');
      return;
    }

    setLoading(true);

    try {
      const response = await fetch(`/api/emergency-fund/${fundId}/withdraw`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          amount: ethers.parseUnits(withdrawAmount, 18).toString(),
          reason: withdrawReason,
          userAddress: address
        })
      });

      if (response.ok) {
        await fetchFunds();
        setWithdrawAmount('');
        setWithdrawReason('');
        setSelectedFund(null);
      }
    } catch (error) {
      console.error('Failed to withdraw:', error);
    } finally {
      setLoading(false);
    }
  };

  const toggleAutoTopUp = async (fundId: string, enabled: boolean) => {
    try {
      await fetch(`/api/automations/${fundId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ metadata: { autoTopUp: enabled } })
      });
      await fetchFunds();
    } catch (error) {
      console.error('Failed to toggle auto top-up:', error);
    }
  };

  const resetForm = () => {
    setFormData({
      fundName: '',
      targetAmount: '',
      minThreshold: '',
      tokenAddress: ethers.ZeroAddress,
      fundAddress: '',
      autoTopUp: true,
      topUpAmount: '',
      checkInterval: 86400,
      notificationThreshold: 80
    });
  };

  const getStatusColor = (status: string): string => {
    switch (status) {
      case 'healthy':
        return 'status-healthy';
      case 'warning':
        return 'status-warning';
      case 'critical':
        return 'status-critical';
      default:
        return '';
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'healthy':
        return <Shield className="text-green-500" size={20} />;
      case 'warning':
        return <AlertTriangle className="text-yellow-500" size={20} />;
      case 'critical':
        return <AlertTriangle className="text-red-500" size={20} />;
      default:
        return null;
    }
  };

  return (
    <div className="emergency-fund-container">
      <div className="header">
        <h2>Emergency Funds</h2>
        <button
          className="create-button"
          onClick={() => setShowCreateForm(!showCreateForm)}
        >
          <Shield size={20} />
          Create Fund
        </button>
      </div>

      {/* Fund Overview */}
      <div className="funds-grid">
        {funds.map((fund) => (
          <div key={fund.id} className={`fund-card ${getStatusColor(fund.status)}`}>
            <div className="fund-header">
              <h3>{fund.name}</h3>
              {getStatusIcon(fund.status)}
            </div>

            <div className="fund-progress">
              <div className="progress-bar">
                <div 
                  className="progress-fill"
                  style={{ width: `${Math.min(fund.percentage, 100)}%` }}
                />
              </div>
              <span className="progress-text">{fund.percentage.toFixed(1)}%</span>
            </div>

            <div className="fund-details">
              <div className="detail-row">
                <span>Current:</span>
                <strong>${fund.currentAmount}</strong>
              </div>
              <div className="detail-row">
                <span>Target:</span>
                <strong>${fund.targetAmount}</strong>
              </div>
              <div className="detail-row">
                <span>Minimum:</span>
                <strong>${fund.minThreshold}</strong>
              </div>
              <div className="detail-row">
                <span>Auto Top-up:</span>
                <label className="toggle-switch">
                  <input
                    type="checkbox"
                    checked={fund.autoTopUp}
                    onChange={(e) => toggleAutoTopUp(fund.id, e.target.checked)}
                  />
                  <span className="toggle-slider" />
                </label>
              </div>
            </div>

            <div className="fund-actions">
              <button
                onClick={() => setSelectedFund(fund)}
                className="action-button deposit"
              >
                <Plus size={16} />
                Deposit
              </button>
              <button
                onClick={() => setSelectedFund(fund)}
                className="action-button withdraw"
              >
                <Minus size={16} />
                Withdraw
              </button>
              <button
                onClick={() => setSelectedFund(fund)}
                className="action-button history"
              >
                <History size={16} />
                History
              </button>
            </div>

            <div className="last-checked">
              Last checked: {fund.lastChecked.toLocaleString()}
            </div>
          </div>
        ))}
      </div>

      {/* Create Fund Form */}
      {showCreateForm && (
        <div className="modal-overlay" onClick={() => setShowCreateForm(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <h3>Create Emergency Fund</h3>
            
            <form onSubmit={handleCreateFund}>
              <div className="form-group">
                <label>Fund Name</label>
                <input
                  type="text"
                  value={formData.fundName}
                  onChange={(e) => setFormData({ ...formData, fundName: e.target.value })}
                  placeholder="e.g., Medical Emergency Fund"
                  required
                />
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label>Target Amount</label>
                  <input
                    type="number"
                    step="0.01"
                    value={formData.targetAmount}
                    onChange={(e) => setFormData({ ...formData, targetAmount: e.target.value })}
                    placeholder="10000"
                    required
                  />
                </div>

                <div className="form-group">
                  <label>Minimum Threshold</label>
                  <input
                    type="number"
                    step="0.01"
                    value={formData.minThreshold}
                    onChange={(e) => setFormData({ ...formData, minThreshold: e.target.value })}
                    placeholder="5000"
                    required
                  />
                </div>
              </div>

              <div className="form-group">
                <label>Fund Storage Address</label>
                <input
                  type="text"
                  value={formData.fundAddress}
                  onChange={(e) => setFormData({ ...formData, fundAddress: e.target.value })}
                  placeholder="0x... (separate wallet or smart contract)"
                  required
                />
              </div>

              <div className="form-group">
                <label>Token</label>
                <select
                  value={formData.tokenAddress}
                  onChange={(e) => setFormData({ ...formData, tokenAddress: e.target.value })}
                >
                  <option value={ethers.ZeroAddress}>ETH</option>
                  <option value="0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48">USDC</option>
                  <option value="0x6B175474E89094C44Da98b954EedeAC495271d0F">DAI</option>
                </select>
              </div>

              <div className="form-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.autoTopUp}
                    onChange={(e) => setFormData({ ...formData, autoTopUp: e.target.checked })}
                  />
                  <span>Enable Auto Top-up</span>
                </label>
              </div>

              {formData.autoTopUp && (
                <div className="form-group">
                  <label>Top-up Amount</label>
                  <input
                    type="number"
                    step="0.01"
                    value={formData.topUpAmount}
                    onChange={(e) => setFormData({ ...formData, topUpAmount: e.target.value })}
                    placeholder="1000"
                    required={formData.autoTopUp}
                  />
                </div>
              )}

              <div className="form-actions">
                <button type="button" onClick={() => setShowCreateForm(false)}>
                  Cancel
                </button>
                <button type="submit" disabled={loading}>
                  {loading ? 'Creating...' : 'Create Fund'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Fund Action Modal */}
      {selectedFund && (
        <div className="modal-overlay" onClick={() => setSelectedFund(null)}>
          <div className="modal-content fund-action" onClick={(e) => e.stopPropagation()}>
            <h3>{selectedFund.name}</h3>
            
            <div className="action-tabs">
              <div className="tab-content">
                <div className="deposit-section">
                  <h4>Deposit Funds</h4>
                  <input
                    type="number"
                    step="0.01"
                    value={depositAmount}
                    onChange={(e) => setDepositAmount(e.target.value)}
                    placeholder="Amount to deposit"
                  />
                  <button
                    onClick={() => handleDeposit(selectedFund.id)}
                    disabled={loading || !depositAmount}
                  >
                    {loading ? 'Processing...' : 'Deposit'}
                  </button>
                </div>

                <div className="withdraw-section">
                  <h4>Emergency Withdrawal</h4>
                  <input
                    type="number"
                    step="0.01"
                    value={withdrawAmount}
                    onChange={(e) => setWithdrawAmount(e.target.value)}
                    placeholder="Amount to withdraw"
                  />
                  <textarea
                    value={withdrawReason}
                    onChange={(e) => setWithdrawReason(e.target.value)}
                    placeholder="Reason for withdrawal (required)"
                    rows={3}
                  />
                  <button
                    onClick={() => handleWithdraw(selectedFund.id)}
                    disabled={loading || !withdrawAmount || !withdrawReason}
                    className="withdraw-button"
                  >
                    {loading ? 'Processing...' : 'Withdraw'}
                  </button>
                </div>

                <div className="history-section">
                  <h4>Transaction History</h4>
                  <div className="history-list">
                    {selectedFund.history.map((event, index) => (
                      <div key={index} className={`history-item ${event.type}`}>
                        <span className="event-type">{event.type}</span>
                        <span className="event-amount">
                          {event.type === 'withdrawal' ? '-' : '+'}
                          {ethers.formatUnits(event.amount, 18)} ETH
                        </span>
                        <span className="event-date">
                          {new Date(event.timestamp).toLocaleDateString()}
                        </span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>

            <button onClick={() => setSelectedFund(null)} className="close-button">
              Close
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

CHARITY_DONATION flow:

import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';

interface CharityConfig extends AutomationConfig {
  metadata: {
    charityName: string;
    charityAddress: string;
    taxId: string; // For tax receipts
    category: string; // education, health, environment, etc.
    donationType: 'one-time' | 'recurring';
    amount: string;
    tokenAddress: string;
    frequency?: 'monthly' | 'quarterly' | 'yearly';
    taxDeductible: boolean;
    roundUpEnabled: boolean; // Round up transactions and donate the difference
    roundUpMax: string; // Maximum round-up per transaction
    totalDonated: string;
    donationHistory: DonationRecord[];
    nextDonationDate?: number;
  };
}

interface DonationRecord {
  amount: string;
  timestamp: number;
  txHash: string;
  taxReceiptId?: string;
  roundUpAmount?: string; // If donation was from round-up
}

interface RoundUpTransaction {
  txHash: string;
  originalAmount: string;
  roundedAmount: string;
  difference: string;
  timestamp: number;
}

export class CharityDonationAutomation {
  private wallyService: WallyService;
  private provider: ethers.Provider;
  private cronJobs: Map<string, NodeJS.Timeout> = new Map();
  private roundUpBuffer: Map<string, RoundUpTransaction[]> = new Map();

  constructor(wallyService: WallyService, provider: ethers.Provider) {
    this.wallyService = wallyService;
    this.provider = provider;
  }

  async start(config: CharityConfig): Promise<void> {
    if (config.metadata.donationType === 'recurring') {
      this.setupRecurringDonation(config);
    }

    if (config.metadata.roundUpEnabled) {
      this.setupRoundUpMonitoring(config);
    }
  }

  stop(configId: string): void {
    const job = this.cronJobs.get(configId);
    if (job) {
      clearInterval(job);
      this.cronJobs.delete(configId);
    }
    this.roundUpBuffer.delete(configId);
  }

  private setupRecurringDonation(config: CharityConfig): void {
    const interval = this.getIntervalMs(config.metadata.frequency!);
    
    const job = setInterval(async () => {
      try {
        await this.processRecurringDonation(config);
      } catch (error) {
        console.error(`Charity donation error for ${config.id}:`, error);
      }
    }, interval);

    this.cronJobs.set(config.id, job);
  }

  private setupRoundUpMonitoring(config: CharityConfig): void {
    // Monitor user transactions and calculate round-ups
    // This would integrate with transaction monitoring
    this.startTransactionMonitoring(config);
  }

  private async startTransactionMonitoring(config: CharityConfig): Promise<void> {
    // Set up event listener for user's transactions
    const filter = {
      address: null, // All addresses
      topics: [
        ethers.id("Transfer(address,address,uint256)"),
        ethers.zeroPadValue(config.walletAddress, 32) // From user
      ]
    };

    this.provider.on(filter, async (log) => {
      await this.processTransactionForRoundUp(config, log);
    });
  }

  private async processTransactionForRoundUp(
    config: CharityConfig,
    log: ethers.Log
  ): Promise<void> {
    try {
      // Decode the transfer event
      const iface = new ethers.Interface([
        "event Transfer(address indexed from, address indexed to, uint256 value)"
      ]);
      const decoded = iface.parseLog(log);
      
      if (!decoded) return;

      const amount = decoded.args.value;
      const roundedAmount = this.calculateRoundUp(amount);
      const difference = roundedAmount - amount;

      if (difference > 0 && difference <= BigInt(config.metadata.roundUpMax)) {
        const roundUpTx: RoundUpTransaction = {
          txHash: log.transactionHash,
          originalAmount: amount.toString(),
          roundedAmount: roundedAmount.toString(),
          difference: difference.toString(),
          timestamp: Date.now()
        };

        // Add to buffer
        if (!this.roundUpBuffer.has(config.id)) {
          this.roundUpBuffer.set(config.id, []);
        }
        this.roundUpBuffer.get(config.id)!.push(roundUpTx);

        // Process round-ups when buffer reaches threshold
        if (this.roundUpBuffer.get(config.id)!.length >= 10) {
          await this.processRoundUpDonations(config);
        }
      }
    } catch (error) {
      console.error('Error processing round-up:', error);
    }
  }

  private calculateRoundUp(amount: bigint): bigint {
    // Round up to nearest dollar/unit
    const unit = ethers.parseUnits("1", 18);
    const remainder = amount % unit;
    
    if (remainder === BigInt(0)) {
      return amount;
    }
    
    return amount + (unit - remainder);
  }

  private async processRoundUpDonations(config: CharityConfig): Promise<void> {
    const roundUps = this.roundUpBuffer.get(config.id);
    if (!roundUps || roundUps.length === 0) return;

    // Calculate total round-up amount
    const totalRoundUp = roundUps.reduce(
      (sum, tx) => sum + BigInt(tx.difference),
      BigInt(0)
    );

    if (totalRoundUp > 0) {
      await this.executeDonation(config, totalRoundUp.toString(), true);
      
      // Clear buffer
      this.roundUpBuffer.set(config.id, []);
    }
  }

  private async processRecurringDonation(config: CharityConfig): Promise<void> {
    const { amount } = config.metadata;
    await this.executeDonation(config, amount, false);
  }

  private async executeDonation(
    config: CharityConfig,
    amount: string,
    isRoundUp: boolean
  ): Promise<void> {
    const { walletAddress, metadata } = config;
    const { charityAddress, tokenAddress, charityName } = metadata;

    // Validate permissions
    const hasPermission = await this.wallyService.validatePermissions(walletAddress);
    if (!hasPermission) {
      console.log(`No valid permission for charity donation: ${walletAddress}`);
      return;
    }

    // Check balance
    const hasBalance = await this.checkSufficientBalance(
      walletAddress,
      tokenAddress,
      amount
    );

    if (!hasBalance) {
      await this.notifyInsufficientBalance(config);
      return;
    }

    const transfer: TransferRequest = {
      wallet: walletAddress,
      token: tokenAddress,
      recipient: charityAddress,
      amount
    };

    try {
      const tx = await this.wallyService.executeTransfer(transfer);
      console.log(`Charity donation executed: ${tx.hash}`);

      // Record donation
      const record: DonationRecord = {
        amount,
        timestamp: Date.now(),
        txHash: tx.hash,
        roundUpAmount: isRoundUp ? amount : undefined
      };

      // Generate tax receipt if applicable
      if (metadata.taxDeductible) {
        record.taxReceiptId = await this.generateTaxReceipt(config, record);
      }

      config.metadata.donationHistory.push(record);
      config.metadata.totalDonated = (
        BigInt(config.metadata.totalDonated) + BigInt(amount)
      ).toString();

      await this.updateConfig(config);
      await this.notifyDonationSuccess(config, amount, tx.hash, isRoundUp);
    } catch (error) {
      console.error('Charity donation failed:', error);
      await this.notifyDonationFailed(config, error);
    }
  }

  async makeOneTimeDonation(
    configId: string,
    amount: string,
    userAddress: string
  ): Promise<void> {
    const config = await this.getConfig(configId);
    
    // Validate user matches config
    if (config.walletAddress !== userAddress) {
      throw new Error('Unauthorized');
    }

    await this.executeDonation(config, amount, false);
  }

  private async generateTaxReceipt(
    config: CharityConfig,
    donation: DonationRecord
  ): Promise<string> {
    // Generate unique receipt ID
    const receiptId = `${config.metadata.taxId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // In a real implementation, this would:
    // 1. Generate PDF receipt
    // 2. Store in IPFS or database
    // 3. Send to user's email
    // 4. Return receipt ID/URL
    
    console.log(`Tax receipt generated: ${receiptId} for ${config.metadata.charityName}`);
    return receiptId;
  }

  async getAnnualTaxSummary(
    userAddress: string,
    year: number
  ): Promise<{
    totalDonated: string;
    charities: Array<{
      name: string;
      taxId: string;
      amount: string;
      receipts: string[];
    }>;
  }> {
    // Fetch all charity configs for user
    const configs = await this.getUserCharityConfigs(userAddress);
    
    const summary = {
      totalDonated: '0',
      charities: [] as any[]
    };

    for (const config of configs) {
      const yearDonations = config.metadata.donationHistory.filter(d => {
        const donationYear = new Date(d.timestamp).getFullYear();
        return donationYear === year && d.taxReceiptId;
      });

      if (yearDonations.length > 0) {
        const charityTotal = yearDonations.reduce(
          (sum, d) => sum + BigInt(d.amount),
          BigInt(0)
        );

        summary.charities.push({
          name: config.metadata.charityName,
          taxId: config.metadata.taxId,
          amount: charityTotal.toString(),
          receipts: yearDonations.map(d => d.taxReceiptId!).filter(Boolean)
        });

        summary.totalDonated = (
          BigInt(summary.totalDonated) + charityTotal
        ).toString();
      }
    }

    return summary;
  }

  private getIntervalMs(frequency: string): number {
    switch (frequency) {
      case 'monthly':
        return 30 * 24 * 60 * 60 * 1000;
      case 'quarterly':
        return 90 * 24 * 60 * 60 * 1000;
      case 'yearly':
        return 365 * 24 * 60 * 60 * 1000;
      default:
        return 30 * 24 * 60 * 60 * 1000;
    }
  }

  private async checkSufficientBalance(
    wallet: string,
    token: string,
    amount: string
  ): Promise<boolean> {
    try {
      let balance: bigint;
      if (token === ethers.ZeroAddress) {
        balance = await this.provider.getBalance(wallet);
      } else {
        const tokenContract = new ethers.Contract(
          token,
          ['function balanceOf(address) view returns (uint256)'],
          this.provider
        );
        balance = await tokenContract.balanceOf(wallet);
      }
      
      return balance >= BigInt(amount);
    } catch (error) {
      console.error('Balance check failed:', error);
      return false;
    }
  }

  // Notification methods
  private async notifyDonationSuccess(
    config: CharityConfig,
    amount: string,
    txHash: string,
    isRoundUp: boolean
  ): Promise<void> {
    const type = isRoundUp ? 'Round-up' : 'Regular';
    console.log(`✅ ${type} donation successful: ${amount} to ${config.metadata.charityName}`);
  }

  private async notifyDonationFailed(config: CharityConfig, error: any): Promise<void> {
    console.error(`❌ Donation failed to ${config.metadata.charityName}:`, error);
  }

  private async notifyInsufficientBalance(config: CharityConfig): Promise<void> {
    console.log(`💸 Insufficient balance for donation to ${config.metadata.charityName}`);
  }

  // Helper methods
  private async getConfig(configId: string): Promise<CharityConfig> {
    // Fetch from database
    throw new Error('Not implemented');
  }

  private async getUserCharityConfigs(userAddress: string): Promise<CharityConfig[]> {
    // Fetch all charity configs for user
    return [];
  }

  private async updateConfig(config: CharityConfig): Promise<void> {
    // Update in database
  }
}

CHARITY_DONATION Component:

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { Heart, TrendingUp, Calendar, Receipt, Award } from 'lucide-react';

interface CharityFormData {
  charityName: string;
  charityAddress: string;
  taxId: string;
  category: string;
  donationType: 'one-time' | 'recurring';
  amount: string;
  tokenAddress: string;
  frequency?: 'monthly' | 'quarterly' | 'yearly';
  taxDeductible: boolean;
  roundUpEnabled: boolean;
  roundUpMax: string;
}

interface Charity {
  id: string;
  name: string;
  address: string;
  taxId: string;
  category: string;
  description: string;
  logo: string;
  verified: boolean;
}

const VERIFIED_CHARITIES: Charity[] = [
  {
    id: '1',
    name: 'GiveDirectly',
    address: '0x750EF1D7a54b69e66F2aF3c3F1f4e31c0A3B3E47', // Example address
    taxId: '27-1661997',
    category: 'poverty',
    description: 'Direct cash transfers to people living in poverty',
    logo: '/charities/givedirectly.png',
    verified: true
  },
  {
    id: '2',
    name: 'The Water Project',
    address: '0x3E5e9111Ae7feBef6E5c1E0e8C7395B1B0B7bB47',
    taxId: '37-1424750',
    category: 'water',
    description: 'Clean water solutions for communities in Africa',
    logo: '/charities/waterproject.png',
    verified: true
  },
  {
    id: '3',
    name: 'Electronic Frontier Foundation',
    address: '0x095f1fD53A66CF59C3C3D3A9c0f9a7Eb2A7bB47',
    taxId: '04-3091431',
    category: 'technology',
    description: 'Defending civil liberties in the digital world',
    logo: '/charities/eff.png',
    verified: true
  }
];

const CHARITY_CATEGORIES = [
  { value: 'poverty', label: 'Poverty & Hunger', icon: '🍞' },
  { value: 'health', label: 'Health & Medicine', icon: '🏥' },
  { value: 'education', label: 'Education', icon: '📚' },
  { value: 'environment', label: 'Environment', icon: '🌳' },
  { value: 'animals', label: 'Animal Welfare', icon: '🐾' },
  { value: 'technology', label: 'Technology & Science', icon: '💻' },
  { value: 'water', label: 'Clean Water', icon: '💧' },
  { value: 'other', label: 'Other', icon: '❤️' }
];

interface DonationStats {
  totalDonated: string;
  totalRoundUp: string;
  taxSavings: string;
  charitiesSupported: number;
}

export const CharityDonationComponent: React.FC = () => {
  const { address } = useWallet();
  const [donations, setDonations] = useState<AutomationConfig[]>([]);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [selectedCharity, setSelectedCharity] = useState<Charity | null>(null);
  const [showTaxSummary, setShowTaxSummary] = useState(false);
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
  const [stats, setStats] = useState<DonationStats | null>(null);
  const [loading, setLoading] = useState(false);
  
  const [formData, setFormData] = useState<CharityFormData>({
    charityName: '',
    charityAddress: '',
    taxId: '',
    category: 'other',
    donationType: 'one-time',
    amount: '',
    tokenAddress: ethers.ZeroAddress,
    frequency: 'monthly',
    taxDeductible: true,
    roundUpEnabled: false,
    roundUpMax: '10'
  });

  useEffect(() => {
    if (address) {
      fetchDonations();
      fetchStats();
    }
  }, [address]);

  const fetchDonations = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.CHARITY_DONATION}`);
      const data = await response.json();
      setDonations(data);
    } catch (error) {
      console.error('Failed to fetch donations:', error);
    }
  };

  const fetchStats = async () => {
    try {
      const response = await fetch(`/api/charity/stats/${address}`);
      const data = await response.json();
      setStats(data);
    } catch (error) {
      console.error('Failed to fetch stats:', error);
    }
  };

  const selectVerifiedCharity = (charity: Charity) => {
    setSelectedCharity(charity);
    setFormData({
      ...formData,
      charityName: charity.name,
      charityAddress: charity.address,
      taxId: charity.taxId,
      category: charity.category
    });
  };

  const handleCreateDonation = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.CHARITY_DONATION,
        walletAddress: address!,
        enabled: true,
        metadata: {
          ...formData,
          totalDonated: '0',
          donationHistory: []
        }
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        await fetchDonations();
        setShowCreateForm(false);
        resetForm();
      }
    } catch (error) {
      console.error('Failed to create donation:', error);
    } finally {
      setLoading(false);
    }
  };

  const makeOneTimeDonation = async (configId: string, amount: string) => {
    setLoading(true);

    try {
      const response = await fetch(`/api/charity/${configId}/donate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          amount: ethers.parseUnits(amount, 18).toString(),
          userAddress: address
        })
      });

      if (response.ok) {
        await fetchDonations();
        await fetchStats();
      }
    } catch (error) {
      console.error('Failed to make donation:', error);
    } finally {
      setLoading(false);
    }
  };

  const toggleRoundUp = async (configId: string, enabled: boolean) => {
    try {
      await fetch(`/api/automations/${configId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ metadata: { roundUpEnabled: enabled } })
      });
      await fetchDonations();
    } catch (error) {
      console.error('Failed to toggle round-up:', error);
    }
  };

  const fetchTaxSummary = async () => {
    try {
      const response = await fetch(`/api/charity/tax-summary/${address}/${selectedYear}`);
      const data = await response.json();
      // Handle tax summary data
      console.log('Tax summary:', data);
    } catch (error) {
      console.error('Failed to fetch tax summary:', error);
    }
  };

  const resetForm = () => {
    setFormData({
      charityName: '',
      charityAddress: '',
      taxId: '',
      category: 'other',
      donationType: 'one-time',
      amount: '',
      tokenAddress: ethers.ZeroAddress,
      frequency: 'monthly',
      taxDeductible: true,
      roundUpEnabled: false,
      roundUpMax: '10'
    });
    setSelectedCharity(null);
  };

  const formatAmount = (amount: string): string => {
    try {
      return parseFloat(ethers.formatUnits(amount, 18)).toFixed(2);
    } catch {
      return '0.00';
    }
  };

  const calculateTaxSavings = (totalDonated: number): number => {
    // Simplified calculation - actual would depend on tax bracket
    const taxRate = 0.22; // 22% tax bracket
    return totalDonated * taxRate;
  };

  return (
    <div className="charity-donation-container">
      <div className="header">
        <h2>Charity Donations</h2>
        <div className="header-actions">
          <button
            className="tax-button"
            onClick={() => setShowTaxSummary(true)}
          >
            <Receipt size={20} />
            Tax Summary
          </button>
          <button
            className="create-button"
            onClick={() => setShowCreateForm(!showCreateForm)}
          >
            <Heart size={20} />
            New Donation
          </button>
        </div>
      </div>

      {/* Stats Overview */}
      {stats && (
        <div className="donation-stats">
          <div className="stat-card">
            <Heart className="stat-icon" />
            <div>
              <p>Total Donated</p>
              <h3>${stats.totalDonated}</h3>
            </div>
          </div>
          <div className="stat-card">
            <TrendingUp className="stat-icon" />
            <div>
              <p>Round-up Total</p>
              <h3>${stats.totalRoundUp}</h3>
            </div>
          </div>
          <div className="stat-card">
            <Receipt className="stat-icon" />
            <div>
              <p>Est. Tax Savings</p>
              <h3>${stats.taxSavings}</h3>
            </div>
          </div>
          <div className="stat-card">
            <Award className="stat-icon" />
            <div>
              <p>Charities Supported</p>
              <h3>{stats.charitiesSupported}</h3>
            </div>
          </div>
        </div>
      )}

      {/* Verified Charities */}
      <div className="verified-charities-section">
        <h3>Verified Charities</h3>
        <div className="charities-grid">
          {VERIFIED_CHARITIES.map((charity) => (
            <div key={charity.id} className="charity-card">
              <div className="charity-header">
                <img src={charity.logo} alt={charity.name} className="charity-logo" />
                <Award className="verified-badge" size={16} />
              </div>
              <h4>{charity.name}</h4>
              <p className="charity-description">{charity.description}</p>
              <p className="charity-taxid">Tax ID: {charity.taxId}</p>
              <button
                onClick={() => {
                  selectVerifiedCharity(charity);
                  setShowCreateForm(true);
                }}
                className="donate-button"
              >
                Donate
              </button>
            </div>
          ))}
        </div>
      </div>

      {/* Active Donations */}
      <div className="active-donations">
        <h3>Your Donations</h3>
        <div className="donations-list">
          {donations.map((donation) => (
            <div key={donation.id} className="donation-item">
              <div className="donation-header">
                <h4>{donation.metadata.charityName}</h4>
                <span className={`donation-type ${donation.metadata.donationType}`}>
                  {donation.metadata.donationType === 'recurring' 
                    ? `${donation.metadata.frequency} recurring`
                    : 'One-time'}
                </span>
              </div>

              <div className="donation-details">
                <div className="detail-row">
                  <span>Total Donated:</span>
                  <strong>${formatAmount(donation.metadata.totalDonated)}</strong>
                </div>
                <div className="detail-row">
                  <span>Tax Deductible:</span>
                  <strong>{donation.metadata.taxDeductible ? 'Yes' : 'No'}</strong>
                </div>
                <div className="detail-row">
                  <span>Round-up Enabled:</span>
                  <label className="toggle-switch">
                    <input
                      type="checkbox"
                      checked={donation.metadata.roundUpEnabled}
                      onChange={(e) => toggleRoundUp(donation.id, e.target.checked)}
                    />
                    <span className="toggle-slider" />
                  </label>
                </div>
              </div>

              {donation.metadata.donationType === 'recurring' && (
                <div className="recurring-info">
                  <p>Amount: ${donation.metadata.amount} {donation.metadata.frequency}</p>
                  <p>Next donation: {new Date(donation.metadata.nextDonationDate || Date.now()).toLocaleDateString()}</p>
                </div>
              )}

              <div className="donation-actions">
                <button
                  onClick={() => {
                    const amount = prompt('Enter donation amount:');
                    if (amount) makeOneTimeDonation(donation.id, amount);
                  }}
                  className="donate-now-button"
                >
                  Donate Now
                </button>
                <button
                  onClick={() => {/* View history */}}
                  className="history-button"
                >
                  View History
                </button>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Create Donation Form */}
      {showCreateForm && (
        <div className="modal-overlay" onClick={() => setShowCreateForm(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <h3>Set Up Donation</h3>
            
            {selectedCharity && (
              <div className="selected-charity">
                <img src={selectedCharity.logo} alt={selectedCharity.name} />
                <h4>{selectedCharity.name}</h4>
                <Award className="verified-badge" size={16} />
              </div>
            )}

            <form onSubmit={handleCreateDonation}>
              {!selectedCharity && (
                <>
                  <div className="form-group">
                    <label>Charity Name</label>
                    <input
                      type="text"
                      value={formData.charityName}
                      onChange={(e) => setFormData({ ...formData, charityName: e.target.value })}
                      placeholder="Enter charity name"
                      required
                    />
                  </div>

                  <div className="form-group">
                    <label>Charity Wallet Address</label>
                    <input
                      type="text"
                      value={formData.charityAddress}
                      onChange={(e) => setFormData({ ...formData, charityAddress: e.target.value })}
                      placeholder="0x..."
                      required
                    />
                  </div>

                  <div className="form-group">
                    <label>Tax ID (Optional)</label>
                    <input
                      type="text"
                      value={formData.taxId}
                      onChange={(e) => setFormData({ ...formData, taxId: e.target.value })}
                      placeholder="XX-XXXXXXX"
                    />
                  </div>
                </>
              )}

              <div className="form-group">
                <label>Category</label>
                <select
                  value={formData.category}
                  onChange={(e) => setFormData({ ...formData, category: e.target.value })}
                >
                  {CHARITY_CATEGORIES.map(cat => (
                    <option key={cat.value} value={cat.value}>
                      {cat.icon} {cat.label}
                    </option>
                  ))}
                </select>
              </div>

              <div className="form-group">
                <label>Donation Type</label>
                <div className="donation-type-selector">
                  <button
                    type="button"
                    className={formData.donationType === 'one-time' ? 'active' : ''}
                    onClick={() => setFormData({ ...formData, donationType: 'one-time' })}
                  >
                    One-time
                  </button>
                  <button
                    type="button"
                    className={formData.donationType === 'recurring' ? 'active' : ''}
                    onClick={() => setFormData({ ...formData, donationType: 'recurring' })}
                  >
                    Recurring
                  </button>
                </div>
              </div>

              {formData.donationType === 'recurring' && (
                <>
                  <div className="form-group">
                    <label>Amount</label>
                    <input
                      type="number"
                      step="0.01"
                      value={formData.amount}
                      onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
                      placeholder="100"
                      required
                    />
                  </div>

                  <div className="form-group">
                    <label>Frequency</label>
                    <select
                      value={formData.frequency}
                      onChange={(e) => setFormData({ ...formData, frequency: e.target.value as any })}
                    >
                      <option value="monthly">Monthly</option>
                      <option value="quarterly">Quarterly</option>
                      <option value="yearly">Yearly</option>
                    </select>
                  </div>
                </>
              )}

              <div className="form-group">
                <label>Token</label>
                <select
                  value={formData.tokenAddress}
                  onChange={(e) => setFormData({ ...formData, tokenAddress: e.target.value })}
                >
                  <option value={ethers.ZeroAddress}>ETH</option>
                  <option value="0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48">USDC</option>
                  <option value="0x6B175474E89094C44Da98b954EedeAC495271d0F">DAI</option>
                </select>
              </div>

              <div className="form-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.taxDeductible}
                    onChange={(e) => setFormData({ ...formData, taxDeductible: e.target.checked })}
                  />
                  <span>Tax Deductible</span>
                </label>
              </div>

              <div className="form-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.roundUpEnabled}
                    onChange={(e) => setFormData({ ...formData, roundUpEnabled: e.target.checked })}
                  />
                  <span>Enable Round-up Donations</span>
                </label>
              </div>

              {formData.roundUpEnabled && (
                <div className="form-group">
                  <label>Maximum Round-up per Transaction</label>
                  <input
                    type="number"
                    step="0.01"
                    value={formData.roundUpMax}
                    onChange={(e) => setFormData({ ...formData, roundUpMax: e.target.value })}
                    placeholder="10"
                  />
                </div>
              )}

              <div className="form-actions">
                <button type="button" onClick={() => setShowCreateForm(false)}>
                  Cancel
                </button>
                <button type="submit" disabled={loading}>
                  {loading ? 'Creating...' : 'Create Donation'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Tax Summary Modal */}
      {showTaxSummary && (
        <div className="modal-overlay" onClick={() => setShowTaxSummary(false)}>
          <div className="modal-content tax-summary" onClick={(e) => e.stopPropagation()}>
            <h3>Tax Summary</h3>
            
            <div className="year-selector">
              <button onClick={() => setSelectedYear(selectedYear - 1)}>←</button>
              <span>{selectedYear}</span>
              <button onClick={() => setSelectedYear(selectedYear + 1)}>→</button>
            </div>

            <div className="tax-content">
              <p>Loading tax summary for {selectedYear}...</p>
              {/* Tax summary content would go here */}
            </div>

            <div className="tax-actions">
              <button onClick={fetchTaxSummary}>
                Download Tax Report
              </button>
              <button onClick={() => setShowTaxSummary(false)}>
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

WALLET_CONSOLIDATION flow:

import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';

interface WalletConfig {
  address: string;
  nickname: string;
  minBalance: string; // Minimum balance to maintain
  priority: number; // Order of consolidation
  lastChecked: number;
  enabled: boolean;
}

interface ConsolidationConfig extends AutomationConfig {
  metadata: {
    consolidationName: string;
    primaryWallet: string;
    sourceWallets: WalletConfig[];
    tokens: string[]; // Token addresses to monitor
    consolidationThreshold: string; // Min value to trigger consolidation
    frequency: 'hourly' | 'daily' | 'weekly' | 'manual';
    gasOptimization: boolean;
    batchTransfers: boolean;
    lastRun: number;
    totalConsolidated: string;
    consolidationHistory: ConsolidationEvent[];
  };
}

interface ConsolidationEvent {
  timestamp: number;
  sourceWallet: string;
  transfers: Array<{
    token: string;
    amount: string;
    txHash: string;
    gasUsed: string;
  }>;
  totalValue: string;
}

interface PendingTransfer {
  sourceWallet: string;
  token: string;
  amount: string;
  estimatedGas: string;
  priority: number;
}

export class MultiWalletConsolidationAutomation {
  private wallyService: WallyService;
  private provider: ethers.Provider;
  private intervals: Map<string, NodeJS.Timeout> = new Map();
  private priceOracle: string;

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    priceOracle: string
  ) {
    this.wallyService = wallyService;
    this.provider = provider;
    this.priceOracle = priceOracle;
  }

  async start(config: ConsolidationConfig): Promise<void> {
    if (this.intervals.has(config.id)) {
      this.stop(config.id);
    }

    // Initial check
    await this.checkAndConsolidate(config);

    // Set up periodic checks based on frequency
    if (config.metadata.frequency !== 'manual') {
      const intervalMs = this.getIntervalMs(config.metadata.frequency);
      
      const interval = setInterval(async () => {
        try {
          await this.checkAndConsolidate(config);
        } catch (error) {
          console.error(`Consolidation error for ${config.id}:`, error);
        }
      }, intervalMs);

      this.intervals.set(config.id, interval);
    }
  }

  stop(configId: string): void {
    const interval = this.intervals.get(configId);
    if (interval) {
      clearInterval(interval);
      this.intervals.delete(configId);
    }
  }

  private async checkAndConsolidate(config: ConsolidationConfig): Promise<void> {
    const { primaryWallet, sourceWallets, tokens, consolidationThreshold } = config.metadata;
    const pendingTransfers: PendingTransfer[] = [];

    // Check each source wallet
    for (const wallet of sourceWallets) {
      if (!wallet.enabled) continue;

      // Validate permissions for this wallet
      const hasPermission = await this.wallyService.validatePermissions(wallet.address);
      if (!hasPermission) {
        console.log(`No valid permission for wallet ${wallet.address}`);
        continue;
      }

      // Check native token balance
      const nativeBalance = await this.provider.getBalance(wallet.address);
      const minBalance = BigInt(wallet.minBalance);
      
      if (nativeBalance > minBalance) {
        const transferAmount = nativeBalance - minBalance;
        const nativeValue = await this.getTokenValue(ethers.ZeroAddress, transferAmount);
        
        if (nativeValue >= parseFloat(consolidationThreshold)) {
          pendingTransfers.push({
            sourceWallet: wallet.address,
            token: ethers.ZeroAddress,
            amount: transferAmount.toString(),
            estimatedGas: '21000',
            priority: wallet.priority
          });
        }
      }

      // Check ERC20 token balances
      for (const tokenAddress of tokens) {
        const balance = await this.getTokenBalance(wallet.address, tokenAddress);
        
        if (balance > 0) {
          const tokenValue = await this.getTokenValue(tokenAddress, balance);
          
          if (tokenValue >= parseFloat(consolidationThreshold)) {
            const gasEstimate = await this.estimateTokenTransferGas(
              wallet.address,
              tokenAddress,
              balance
            );
            
            pendingTransfers.push({
              sourceWallet: wallet.address,
              token: tokenAddress,
              amount: balance.toString(),
              estimatedGas: gasEstimate.toString(),
              priority: wallet.priority
            });
          }
        }
      }

      // Update last checked time
      wallet.lastChecked = Date.now();
    }

    // Execute consolidation if there are pending transfers
    if (pendingTransfers.length > 0) {
      await this.executeConsolidation(config, pendingTransfers);
    }

    // Update config
    config.metadata.lastRun = Date.now();
    await this.updateConfig(config);
  }

  private async executeConsolidation(
    config: ConsolidationConfig,
    pendingTransfers: PendingTransfer[]
  ): Promise<void> {
    const { primaryWallet, gasOptimization, batchTransfers } = config.metadata;
    
    // Sort transfers by priority and gas efficiency if optimization is enabled
    if (gasOptimization) {
      pendingTransfers.sort((a, b) => {
        // First by priority
        if (a.priority !== b.priority) {
          return b.priority - a.priority;
        }
        // Then by gas efficiency (value per gas)
        const aEfficiency = parseFloat(a.amount) / parseFloat(a.estimatedGas);
        const bEfficiency = parseFloat(b.amount) / parseFloat(b.estimatedGas);
        return bEfficiency - aEfficiency;
      });
    }

    const consolidationEvent: ConsolidationEvent = {
      timestamp: Date.now(),
      sourceWallet: '',
      transfers: [],
      totalValue: '0'
    };

    // Group transfers by source wallet if batch transfers enabled
    if (batchTransfers) {
      const walletGroups = this.groupTransfersByWallet(pendingTransfers);
      
      for (const [wallet, transfers] of walletGroups) {
        try {
          // Execute batch transfer for this wallet
          const batchRequest = transfers.map(t => ({
            wallet: t.sourceWallet,
            token: t.token,
            recipient: primaryWallet,
            amount: t.amount
          }));

          const tx = await this.wallyService.executeBatchTransfer(batchRequest);
          console.log(`Batch consolidation executed from ${wallet}: ${tx.hash}`);

          // Record transfers
          for (const transfer of transfers) {
            consolidationEvent.transfers.push({
              token: transfer.token,
              amount: transfer.amount,
              txHash: tx.hash,
              gasUsed: transfer.estimatedGas
            });
          }
        } catch (error) {
          console.error(`Batch consolidation failed for ${wallet}:`, error);
        }
      }
    } else {
      // Execute individual transfers
      for (const transfer of pendingTransfers) {
        try {
          const request: TransferRequest = {
            wallet: transfer.sourceWallet,
            token: transfer.token,
            recipient: primaryWallet,
            amount: transfer.amount
          };

          const tx = await this.wallyService.executeTransfer(request);
          console.log(`Consolidation executed: ${tx.hash}`);

          consolidationEvent.sourceWallet = transfer.sourceWallet;
          consolidationEvent.transfers.push({
            token: transfer.token,
            amount: transfer.amount,
            txHash: tx.hash,
            gasUsed: transfer.estimatedGas
          });

          // Add delay between transfers to avoid rate limiting
          await this.delay(1000);
        } catch (error) {
          console.error(`Consolidation failed for ${transfer.sourceWallet}:`, error);
        }
      }
    }

    // Calculate total consolidated value
    let totalValue = BigInt(0);
    for (const transfer of consolidationEvent.transfers) {
      const value = await this.getTokenValue(transfer.token, BigInt(transfer.amount));
      totalValue += BigInt(Math.floor(value * 1e18));
    }
    consolidationEvent.totalValue = totalValue.toString();

    // Update history and total
    config.metadata.consolidationHistory.push(consolidationEvent);
    config.metadata.totalConsolidated = (
      BigInt(config.metadata.totalConsolidated) + totalValue
    ).toString();

    await this.notifyConsolidationComplete(config, consolidationEvent);
  }

  private groupTransfersByWallet(
    transfers: PendingTransfer[]
  ): Map<string, PendingTransfer[]> {
    const groups = new Map<string, PendingTransfer[]>();
    
    for (const transfer of transfers) {
      const wallet = transfer.sourceWallet;
      if (!groups.has(wallet)) {
        groups.set(wallet, []);
      }
      groups.get(wallet)!.push(transfer);
    }
    
    return groups;
  }

  async addSourceWallet(
    configId: string,
    wallet: WalletConfig
  ): Promise<void> {
    const config = await this.getConfig(configId);
    
    // Check if wallet already exists
    const exists = config.metadata.sourceWallets.some(
      w => w.address.toLowerCase() === wallet.address.toLowerCase()
    );
    
    if (!exists) {
      config.metadata.sourceWallets.push(wallet);
      await this.updateConfig(config);
    }
  }

  async removeSourceWallet(
    configId: string,
    walletAddress: string
  ): Promise<void> {
    const config = await this.getConfig(configId);
    
    config.metadata.sourceWallets = config.metadata.sourceWallets.filter(
      w => w.address.toLowerCase() !== walletAddress.toLowerCase()
    );
    
    await this.updateConfig(config);
  }

  async toggleWallet(
    configId: string,
    walletAddress: string,
    enabled: boolean
  ): Promise<void> {
    const config = await this.getConfig(configId);
    
    const wallet = config.metadata.sourceWallets.find(
      w => w.address.toLowerCase() === walletAddress.toLowerCase()
    );
    
    if (wallet) {
      wallet.enabled = enabled;
      await this.updateConfig(config);
    }
  }

  async manualConsolidation(
    configId: string,
    specificWallets?: string[]
  ): Promise<void> {
    const config = await this.getConfig(configId);
    
    // If specific wallets provided, temporarily filter
    if (specificWallets && specificWallets.length > 0) {
      const originalWallets = config.metadata.sourceWallets;
      config.metadata.sourceWallets = config.metadata.sourceWallets.filter(
        w => specificWallets.includes(w.address.toLowerCase())
      );
      
      await this.checkAndConsolidate(config);
      
      // Restore original wallets
      config.metadata.sourceWallets = originalWallets;
    } else {
      await this.checkAndConsolidate(config);
    }
  }

  private getIntervalMs(frequency: string): number {
    switch (frequency) {
      case 'hourly':
        return 60 * 60 * 1000;
      case 'daily':
        return 24 * 60 * 60 * 1000;
      case 'weekly':
        return 7 * 24 * 60 * 60 * 1000;
      default:
        return 24 * 60 * 60 * 1000;
    }
  }

  private async getTokenBalance(
    wallet: string,
    tokenAddress: string
  ): Promise<bigint> {
    const tokenContract = new ethers.Contract(
      tokenAddress,
      ['function balanceOf(address) view returns (uint256)'],
      this.provider
    );
    return tokenContract.balanceOf(wallet);
  }

  private async getTokenValue(
    tokenAddress: string,
    amount: bigint
  ): Promise<number> {
    // Get token price from oracle
    // Simplified implementation
    const price = tokenAddress === ethers.ZeroAddress ? 2000 : 1; // ETH vs stablecoin
    return parseFloat(ethers.formatUnits(amount, 18)) * price;
  }

  private async estimateTokenTransferGas(
    from: string,
    token: string,
    amount: bigint
  ): Promise<bigint> {
    // Estimate gas for ERC20 transfer
    return BigInt(65000);
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Notification methods
  private async notifyConsolidationComplete(
    config: ConsolidationConfig,
    event: ConsolidationEvent
  ): Promise<void> {
    const totalValueFormatted = ethers.formatUnits(event.totalValue, 18);
    console.log(`✅ Consolidation complete: ${event.transfers.length} transfers, $${totalValueFormatted} total`);
  }

  // Helper methods
  private async getConfig(configId: string): Promise<ConsolidationConfig> {
    // Fetch from database
    throw new Error('Not implemented');
  }

  private async updateConfig(config: ConsolidationConfig): Promise<void> {
    // Update in database
  }
}

WALLET_CONSOLIDATION Component:

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { 
  Wallet, 
  GitMerge, 
  Plus, 
  Settings, 
  TrendingDown, 
  Clock,
  ToggleLeft,
  ToggleRight,
  RefreshCw
} from 'lucide-react';

interface ConsolidationFormData {
  consolidationName: string;
  primaryWallet: string;
  frequency: 'hourly' | 'daily' | 'weekly' | 'manual';
  consolidationThreshold: string;
  gasOptimization: boolean;
  batchTransfers: boolean;
}

interface SourceWallet {
  address: string;
  nickname: string;
  minBalance: string;
  priority: number;
  enabled: boolean;
  lastChecked: Date;
  currentBalance?: string;
}

interface ConsolidationStats {
  totalConsolidated: string;
  lastRun: Date;
  activeWallets: number;
  recentTransfers: number;
}

const DEFAULT_TOKENS = [
  { symbol: 'ETH', address: ethers.ZeroAddress },
  { symbol: 'USDC', address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' },
  { symbol: 'DAI', address: '0x6B175474E89094C44Da98b954EedeAC495271d0F' },
  { symbol: 'USDT', address: '0xdAC17F958D2ee523a2206206994597C13D831ec7' }
];

export const MultiWalletConsolidationComponent: React.FC = () => {
  const { address } = useWallet();
  const [consolidations, setConsolidations] = useState<AutomationConfig[]>([]);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [showAddWallet, setShowAddWallet] = useState(false);
  const [selectedConsolidation, setSelectedConsolidation] = useState<AutomationConfig | null>(null);
  const [loading, setLoading] = useState(false);
  const [stats, setStats] = useState<ConsolidationStats | null>(null);
  
  const [formData, setFormData] = useState<ConsolidationFormData>({
    consolidationName: '',
    primaryWallet: '',
    frequency: 'daily',
    consolidationThreshold: '10',
    gasOptimization: true,
    batchTransfers: true
  });

  const [newWallet, setNewWallet] = useState({
    address: '',
    nickname: '',
    minBalance: '0.01',
    priority: 1
  });

  useEffect(() => {
    if (address) {
      fetchConsolidations();
    }
  }, [address]);

  const fetchConsolidations = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.WALLET_CONSOLIDATION}`);
      const data = await response.json();
      setConsolidations(data);
      
      // Calculate stats
      if (data.length > 0) {
        const totalConsolidated = data.reduce((sum: number, c: AutomationConfig) => 
          sum + parseFloat(ethers.formatUnits(c.metadata.totalConsolidated || '0', 18)), 0
        );
        
        const activeWallets = data.reduce((sum: number, c: AutomationConfig) => 
          sum + c.metadata.sourceWallets.filter((w: any) => w.enabled).length, 0
        );
        
        setStats({
          totalConsolidated: totalConsolidated.toFixed(2),
          lastRun: new Date(Math.max(...data.map((c: AutomationConfig) => c.metadata.lastRun || 0))),
          activeWallets,
          recentTransfers: data.reduce((sum: number, c: AutomationConfig) => 
            sum + (c.metadata.consolidationHistory?.length || 0), 0
          )
        });
      }
    } catch (error) {
      console.error('Failed to fetch consolidations:', error);
    }
  };

  const handleCreateConsolidation = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.WALLET_CONSOLIDATION,
        walletAddress: address!,
        enabled: true,
        metadata: {
          ...formData,
          sourceWallets: [],
          tokens: DEFAULT_TOKENS.map(t => t.address),
          lastRun: 0,
          totalConsolidated: '0',
          consolidationHistory: []
        }
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        await fetchConsolidations();
        setShowCreateForm(false);
        resetForm();
      }
    } catch (error) {
      console.error('Failed to create consolidation:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleAddWallet = async (consolidationId: string) => {
    setLoading(true);

    try {
      const response = await fetch(`/api/consolidation/${consolidationId}/wallets`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...newWallet,
          enabled: true,
          lastChecked: Date.now()
        })
      });

      if (response.ok) {
        await fetchConsolidations();
        setShowAddWallet(false);
        setNewWallet({
          address: '',
          nickname: '',
          minBalance: '0.01',
          priority: 1
        });
      }
    } catch (error) {
      console.error('Failed to add wallet:', error);
    } finally {
      setLoading(false);
    }
  };

  const toggleWallet = async (consolidationId: string, walletAddress: string, enabled: boolean) => {
    try {
      await fetch(`/api/consolidation/${consolidationId}/wallets/${walletAddress}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled })
      });
      await fetchConsolidations();
    } catch (error) {
      console.error('Failed to toggle wallet:', error);
    }
  };

  const removeWallet = async (consolidationId: string, walletAddress: string) => {
    if (!confirm('Are you sure you want to remove this wallet?')) return;
    
    try {
      await fetch(`/api/consolidation/${consolidationId}/wallets/${walletAddress}`, {
        method: 'DELETE'
      });
      await fetchConsolidations();
    } catch (error) {
      console.error('Failed to remove wallet:', error);
    }
  };

  const triggerManualConsolidation = async (consolidationId: string) => {
    setLoading(true);

    try {
      await fetch(`/api/consolidation/${consolidationId}/trigger`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userAddress: address })
      });
      
      await fetchConsolidations();
    } catch (error) {
      console.error('Failed to trigger consolidation:', error);
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      consolidationName: '',
      primaryWallet: '',
      frequency: 'daily',
      consolidationThreshold: '10',
      gasOptimization: true,
      batchTransfers: true
    });
  };

  const getFrequencyLabel = (frequency: string): string => {
    const labels = {
      hourly: 'Every Hour',
      daily: 'Daily',
      weekly: 'Weekly',
      manual: 'Manual Only'
    };
    return labels[frequency] || frequency;
  };

  const getWalletBalance = async (walletAddress: string): Promise<string> => {
    try {
      const balance = await ethers.provider.getBalance(walletAddress);
      return ethers.formatEther(balance);
    } catch {
      return '0';
    }
  };

  return (
    <div className="multi-wallet-consolidation-container">
      <div className="header">
        <h2>Multi-Wallet Consolidation</h2>
        <button
          className="create-button"
          onClick={() => setShowCreateForm(!showCreateForm)}
        >
          <GitMerge size={20} />
          New Consolidation
        </button>
      </div>

      {/* Stats Overview */}
      {stats && (
        <div className="stats-overview">
          <div className="stat-card">
            <TrendingDown size={24} />
            <div>
              <p>Total Consolidated</p>
              <h3>${stats.totalConsolidated}</h3>
            </div>
          </div>
          <div className="stat-card">
            <Wallet size={24} />
            <div>
              <p>Active Wallets</p>
              <h3>{stats.activeWallets}</h3>
            </div>
          </div>
          <div className="stat-card">
            <GitMerge size={24} />
            <div>
              <p>Total Transfers</p>
              <h3>{stats.recentTransfers}</h3>
            </div>
          </div>
          <div className="stat-card">
            <Clock size={24} />
            <div>
              <p>Last Run</p>
              <h3>{stats.lastRun.toLocaleString()}</h3>
            </div>
          </div>
        </div>
      )}

      {/* Consolidation Configurations */}
      <div className="consolidations-list">
        {consolidations.map((config) => (
          <div key={config.id} className="consolidation-card">
            <div className="consolidation-header">
              <h3>{config.metadata.consolidationName}</h3>
              <div className="consolidation-status">
                {config.enabled ? (
                  <span className="status-active">Active</span>
                ) : (
                  <span className="status-inactive">Inactive</span>
                )}
              </div>
            </div>

            <div className="consolidation-info">
              <div className="info-row">
                <span>Primary Wallet:</span>
                <code>{config.metadata.primaryWallet.slice(0, 10)}...{config.metadata.primaryWallet.slice(-8)}</code>
              </div>
              <div className="info-row">
                <span>Frequency:</span>
                <span>{getFrequencyLabel(config.metadata.frequency)}</span>
              </div>
              <div className="info-row">
                <span>Threshold:</span>
                <span>${config.metadata.consolidationThreshold}</span>
              </div>
              <div className="info-row">
                <span>Source Wallets:</span>
                <span>{config.metadata.sourceWallets.length}</span>
              </div>
            </div>

            {/* Source Wallets */}
            <div className="source-wallets">
              <div className="wallets-header">
                <h4>Source Wallets</h4>
                <button
                  onClick={() => {
                    setSelectedConsolidation(config);
                    setShowAddWallet(true);
                  }}
                  className="add-wallet-button"
                >
                  <Plus size={16} />
                  Add Wallet
                </button>
              </div>

              <div className="wallets-list">
                {config.metadata.sourceWallets.map((wallet: SourceWallet) => (
                  <div key={wallet.address} className="wallet-item">
                    <div className="wallet-info">
                      <div className="wallet-main">
                        <span className="wallet-nickname">{wallet.nickname}</span>
                        <code className="wallet-address">
                          {wallet.address.slice(0, 6)}...{wallet.address.slice(-4)}
                        </code>
                      </div>
                      <div className="wallet-meta">
                        <span>Min: {wallet.minBalance} ETH</span>
                        <span>Priority: {wallet.priority}</span>
                        <span>Last: {new Date(wallet.lastChecked).toLocaleDateString()}</span>
                      </div>
                    </div>
                    
                    <div className="wallet-actions">
                      <button
                        onClick={() => toggleWallet(config.id, wallet.address, !wallet.enabled)}
                        className="toggle-button"
                      >
                        {wallet.enabled ? <ToggleRight size={20} /> : <ToggleLeft size={20} />}
                      </button>
                      <button
                        onClick={() => removeWallet(config.id, wallet.address)}
                        className="remove-button"
                      >
                        ×
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="consolidation-actions">
              <button
                onClick={() => triggerManualConsolidation(config.id)}
                disabled={loading}
                className="trigger-button"
              >
                <RefreshCw size={16} />
                {loading ? 'Consolidating...' : 'Consolidate Now'}
              </button>
              <button
                onClick={() => setSelectedConsolidation(config)}
                className="settings-button"
              >
                <Settings size={16} />
                Settings
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Create Consolidation Form */}
      {showCreateForm && (
        <div className="modal-overlay" onClick={() => setShowCreateForm(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <h3>Create Consolidation Configuration</h3>
            
            <form onSubmit={handleCreateConsolidation}>
              <div className="form-group">
                <label>Configuration Name</label>
                <input
                  type="text"
                  value={formData.consolidationName}
                  onChange={(e) => setFormData({ ...formData, consolidationName: e.target.value })}
                  placeholder="e.g., Weekly Wallet Cleanup"
                  required
                />
              </div>

              <div className="form-group">
                <label>Primary Wallet (Destination)</label>
                <input
                  type="text"
                  value={formData.primaryWallet}
                  onChange={(e) => setFormData({ ...formData, primaryWallet: e.target.value })}
                  placeholder="0x..."
                  required
                />
              </div>

              <div className="form-group">
                <label>Consolidation Frequency</label>
                <select
                  value={formData.frequency}
                  onChange={(e) => setFormData({ ...formData, frequency: e.target.value as any })}
                >
                  <option value="hourly">Every Hour</option>
                  <option value="daily">Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="manual">Manual Only</option>
                </select>
              </div>

              <div className="form-group">
                <label>Minimum Value Threshold (USD)</label>
                <input
                  type="number"
                  step="0.01"
                  value={formData.consolidationThreshold}
                  onChange={(e) => setFormData({ ...formData, consolidationThreshold: e.target.value })}
                  placeholder="10"
                  required
                />
                <small>Only consolidate tokens worth more than this amount</small>
              </div>

              <div className="form-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.gasOptimization}
                    onChange={(e) => setFormData({ ...formData, gasOptimization: e.target.checked })}
                  />
                  <span>Enable Gas Optimization</span>
                </label>
                <small>Prioritize transfers by gas efficiency</small>
              </div>

              <div className="form-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.batchTransfers}
                    onChange={(e) => setFormData({ ...formData, batchTransfers: e.target.checked })}
                  />
                  <span>Enable Batch Transfers</span>
                </label>
                <small>Group multiple transfers to save gas</small>
              </div>

              <div className="form-actions">
                <button type="button" onClick={() => setShowCreateForm(false)}>
                  Cancel
                </button>
                <button type="submit" disabled={loading}>
                  {loading ? 'Creating...' : 'Create Configuration'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Add Wallet Modal */}
      {showAddWallet && selectedConsolidation && (
        <div className="modal-overlay" onClick={() => setShowAddWallet(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <h3>Add Source Wallet</h3>
            
            <form onSubmit={(e) => {
              e.preventDefault();
              handleAddWallet(selectedConsolidation.id);
            }}>
              <div className="form-group">
                <label>Wallet Address</label>
                <input
                  type="text"
                  value={newWallet.address}
                  onChange={(e) => setNewWallet({ ...newWallet, address: e.target.value })}
                  placeholder="0x..."
                  required
                />
              </div>

              <div className="form-group">
                <label>Nickname</label>
                <input
                  type="text"
                  value={newWallet.nickname}
                  onChange={(e) => setNewWallet({ ...newWallet, nickname: e.target.value })}
                  placeholder="e.g., Old Hardware Wallet"
                  required
                />
              </div>

              <div className="form-group">
                <label>Minimum Balance to Maintain (ETH)</label>
                <input
                  type="number"
                  step="0.001"
                  value={newWallet.minBalance}
                  onChange={(e) => setNewWallet({ ...newWallet, minBalance: e.target.value })}
                  placeholder="0.01"
                  required
                />
                <small>Keep at least this amount for gas fees</small>
              </div>

              <div className="form-group">
                <label>Priority (1-10)</label>
                <input
                  type="number"
                  min="1"
                  max="10"
                  value={newWallet.priority}
                  onChange={(e) => setNewWallet({ ...newWallet, priority: Number(e.target.value) })}
                  required
                />
                <small>Higher priority wallets are consolidated first</small>
              </div>

              <div className="form-actions">
                <button type="button" onClick={() => setShowAddWallet(false)}>
                  Cancel
                </button>
                <button type="submit" disabled={loading}>
                  {loading ? 'Adding...' : 'Add Wallet'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
};


WALLET_ZERO_OUT Flow:

  import { ethers } from 'ethers';
import { WallyService } from '../services/WallyService.js';
import { AutomationConfig, TransferRequest } from '../../shared/types.js';

interface ZeroOutConfig extends AutomationConfig {
  metadata: {
    sourceWallet: string;
    targetWallet: string;
    includeNFTs: boolean;
    includeTokens: boolean;
    includeNative: boolean;
    minTokenValueUSD: number; // Minimum value to bother transferring
    gasStrategy: 'fast' | 'standard' | 'slow';
    scanDepth: 'basic' | 'deep'; // Basic: known tokens, Deep: all contracts
    priorityOrder: 'value' | 'gas-efficient' | 'type';
    excludedTokens: string[]; // Tokens to skip (scams, locked, etc.)
    executionMode: 'immediate' | 'scheduled';
    scheduledTime?: number;
    estimatedValue: string;
    discoveredAssets: Asset[];
    executionPlan: TransferPlan[];
    status: 'scanning' | 'planning' | 'executing' | 'completed' | 'failed';
  };
}

interface Asset {
  type: 'native' | 'erc20' | 'erc721' | 'erc1155';
  address: string;
  symbol: string;
  name: string;
  balance: string;
  decimals?: number;
  tokenId?: string;
  valueUSD: number;
  gasEstimate: string;
  priority: number;
}

interface TransferPlan {
  asset: Asset;
  order: number;
  gasPrice: string;
  maxGas: string;
  status: 'pending' | 'executing' | 'completed' | 'failed';
  txHash?: string;
  error?: string;
}

export class ZeroOutWalletAutomation {
  private wallyService: WallyService;
  private provider: ethers.Provider;
  private tokenListProvider: string; // Uniswap token list or similar
  private priceOracle: string;
  private activeScans: Map<string, AbortController> = new Map();

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    tokenListProvider: string,
    priceOracle: string
  ) {
    this.wallyService = wallyService;
    this.provider = provider;
    this.tokenListProvider = tokenListProvider;
    this.priceOracle = priceOracle;
  }

  async start(config: ZeroOutConfig): Promise<void> {
    // Create abort controller for cancellation
    const abortController = new AbortController();
    this.activeScans.set(config.id, abortController);

    try {
      // Phase 1: Asset Discovery
      config.metadata.status = 'scanning';
      await this.updateConfig(config);
      
      const assets = await this.discoverAssets(config, abortController.signal);
      config.metadata.discoveredAssets = assets;
      
      // Calculate total value
      const totalValue = assets.reduce((sum, asset) => sum + asset.valueUSD, 0);
      config.metadata.estimatedValue = totalValue.toFixed(2);

      // Phase 2: Execution Planning
      config.metadata.status = 'planning';
      await this.updateConfig(config);
      
      const executionPlan = await this.createExecutionPlan(config, assets);
      config.metadata.executionPlan = executionPlan;

      // Phase 3: Execute transfers
      if (config.metadata.executionMode === 'immediate') {
        await this.executeZeroOut(config);
      } else if (config.metadata.scheduledTime && Date.now() >= config.metadata.scheduledTime) {
        await this.executeZeroOut(config);
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log(`Zero-out scan cancelled for ${config.id}`);
      } else {
        console.error(`Zero-out error for ${config.id}:`, error);
        config.metadata.status = 'failed';
        await this.updateConfig(config);
      }
    } finally {
      this.activeScans.delete(config.id);
    }
  }

  stop(configId: string): void {
    const controller = this.activeScans.get(configId);
    if (controller) {
      controller.abort();
      this.activeScans.delete(configId);
    }
  }

  private async discoverAssets(
    config: ZeroOutConfig,
    signal: AbortSignal
  ): Promise<Asset[]> {
    const assets: Asset[] = [];
    const { sourceWallet, includeNative, includeTokens, includeNFTs, scanDepth } = config.metadata;

    // 1. Scan native balance
    if (includeNative) {
      const nativeBalance = await this.provider.getBalance(sourceWallet);
      if (nativeBalance > 0) {
        const nativePrice = await this.getNativeTokenPrice();
        const valueUSD = parseFloat(ethers.formatEther(nativeBalance)) * nativePrice;
        
        assets.push({
          type: 'native',
          address: ethers.ZeroAddress,
          symbol: 'ETH',
          name: 'Ethereum',
          balance: nativeBalance.toString(),
          valueUSD,
          gasEstimate: '21000',
          priority: 1 // Native should usually go last
        });
      }
    }

    // 2. Scan ERC20 tokens
    if (includeTokens) {
      const tokens = await this.discoverERC20Tokens(sourceWallet, scanDepth, signal);
      
      for (const token of tokens) {
        if (signal.aborted) break;
        
        const balance = await this.getTokenBalance(sourceWallet, token.address);
        if (balance > 0) {
          const price = await this.getTokenPrice(token.address);
          const valueUSD = parseFloat(ethers.formatUnits(balance, token.decimals)) * price;
          
          // Skip if below minimum value
          if (valueUSD < config.metadata.minTokenValueUSD) continue;
          
          // Skip excluded tokens
          if (config.metadata.excludedTokens.includes(token.address)) continue;
          
          const gasEstimate = await this.estimateTokenTransferGas(
            sourceWallet,
            token.address,
            balance
          );
          
          assets.push({
            type: 'erc20',
            address: token.address,
            symbol: token.symbol,
            name: token.name,
            balance: balance.toString(),
            decimals: token.decimals,
            valueUSD,
            gasEstimate: gasEstimate.toString(),
            priority: this.calculatePriority(valueUSD, gasEstimate)
          });
        }
      }
    }

    // 3. Scan NFTs
    if (includeNFTs) {
      const nfts = await this.discoverNFTs(sourceWallet, signal);
      
      for (const nft of nfts) {
        if (signal.aborted) break;
        
        const floorPrice = await this.getNFTFloorPrice(nft.address);
        const valueUSD = floorPrice;
        
        const gasEstimate = await this.estimateNFTTransferGas(
          sourceWallet,
          nft.address,
          nft.tokenId
        );
        
        assets.push({
          type: nft.type,
          address: nft.address,
          symbol: nft.symbol,
          name: nft.name,
          balance: '1',
          tokenId: nft.tokenId,
          valueUSD,
          gasEstimate: gasEstimate.toString(),
          priority: this.calculatePriority(valueUSD, gasEstimate)
        });
      }
    }

    return assets;
  }

  private async createExecutionPlan(
    config: ZeroOutConfig,
    assets: Asset[]
  ): Promise<TransferPlan[]> {
    const { priorityOrder, gasStrategy } = config.metadata;
    
    // Sort assets based on priority
    const sortedAssets = this.sortAssetsByPriority(assets, priorityOrder);
    
    // Get current gas prices
    const gasPrices = await this.getGasPrices();
    const gasPrice = gasPrices[gasStrategy];
    
    // Create execution plan
    const plan: TransferPlan[] = [];
    let order = 0;
    
    // Process ERC20s and NFTs first (they need native token for gas)
    const nonNativeAssets = sortedAssets.filter(a => a.type !== 'native');
    const nativeAsset = sortedAssets.find(a => a.type === 'native');
    
    for (const asset of nonNativeAssets) {
      plan.push({
        asset,
        order: order++,
        gasPrice: gasPrice.toString(),
        maxGas: (BigInt(asset.gasEstimate) * BigInt(120) / BigInt(100)).toString(), // 20% buffer
        status: 'pending'
      });
    }
    
    // Process native token last (after all gas is spent)
    if (nativeAsset) {
      // Calculate remaining native balance after all gas fees
      const totalGasCost = plan.reduce((sum, p) => {
        return sum + BigInt(p.maxGas) * BigInt(p.gasPrice);
      }, BigInt(0));
      
      const adjustedNativeBalance = BigInt(nativeAsset.balance) - totalGasCost;
      
      if (adjustedNativeBalance > 0) {
        nativeAsset.balance = adjustedNativeBalance.toString();
        plan.push({
          asset: nativeAsset,
          order: order++,
          gasPrice: gasPrice.toString(),
          maxGas: '21000',
          status: 'pending'
        });
      }
    }
    
    return plan;
  }

  private async executeZeroOut(config: ZeroOutConfig): Promise<void> {
    config.metadata.status = 'executing';
    await this.updateConfig(config);
    
    const { sourceWallet, targetWallet, executionPlan } = config.metadata;
    
    // Validate permissions
    const hasPermission = await this.wallyService.validatePermissions(sourceWallet);
    if (!hasPermission) {
      throw new Error('No valid permission for source wallet');
    }
    
    // Execute transfers in order
    for (const planItem of executionPlan) {
      if (planItem.status === 'completed') continue;
      
      try {
        planItem.status = 'executing';
        await this.updateConfig(config);
        
        let tx: ethers.TransactionResponse;
        
        if (planItem.asset.type === 'native') {
          // Native token transfer
          const transfer: TransferRequest = {
            wallet: sourceWallet,
            token: ethers.ZeroAddress,
            recipient: targetWallet,
            amount: planItem.asset.balance
          };
          tx = await this.wallyService.executeTransfer(transfer);
        } else if (planItem.asset.type === 'erc20') {
          // ERC20 token transfer
          const transfer: TransferRequest = {
            wallet: sourceWallet,
            token: planItem.asset.address,
            recipient: targetWallet,
            amount: planItem.asset.balance
          };
          tx = await this.wallyService.executeTransfer(transfer);
        } else if (planItem.asset.type === 'erc721' || planItem.asset.type === 'erc1155') {
          // NFT transfer (would need additional NFT transfer method in WallyService)
          tx = await this.transferNFT(
            sourceWallet,
            targetWallet,
            planItem.asset.address,
            planItem.asset.tokenId!,
            planItem.asset.type
          );
        }
        
        planItem.status = 'completed';
        planItem.txHash = tx.hash;
        
        console.log(`Transferred ${planItem.asset.symbol}: ${tx.hash}`);
        await this.notifyTransferComplete(config, planItem);
        
      } catch (error) {
        planItem.status = 'failed';
        planItem.error = error.message;
        console.error(`Failed to transfer ${planItem.asset.symbol}:`, error);
        await this.notifyTransferFailed(config, planItem, error);
      }
      
      await this.updateConfig(config);
    }
    
    // Check if all transfers completed
    const allCompleted = executionPlan.every(p => p.status === 'completed');
    config.metadata.status = allCompleted ? 'completed' : 'failed';
    await this.updateConfig(config);
    
    if (allCompleted) {
      await this.notifyZeroOutComplete(config);
    }
  }

  private sortAssetsByPriority(
    assets: Asset[],
    priorityOrder: string
  ): Asset[] {
    switch (priorityOrder) {
      case 'value':
        return assets.sort((a, b) => b.valueUSD - a.valueUSD);
      case 'gas-efficient':
        return assets.sort((a, b) => {
          const aEfficiency = a.valueUSD / parseFloat(a.gasEstimate);
          const bEfficiency = b.valueUSD / parseFloat(b.gasEstimate);
          return bEfficiency - aEfficiency;
        });
      case 'type':
        // NFTs first, then ERC20s, then native
        return assets.sort((a, b) => {
          const typeOrder = { 'erc721': 0, 'erc1155': 0, 'erc20': 1, 'native': 2 };
          return typeOrder[a.type] - typeOrder[b.type];
        });
      default:
        return assets;
    }
  }

  private calculatePriority(valueUSD: number, gasEstimate: bigint): number {
    // Higher value and lower gas = higher priority
    const gasUSD = parseFloat(ethers.formatUnits(gasEstimate, 'gwei')) * 0.00001; // Rough estimate
    return valueUSD / gasUSD;
  }

  // Helper methods
  private async discoverERC20Tokens(
    wallet: string,
    scanDepth: string,
    signal: AbortSignal
  ): Promise<any[]> {
    if (scanDepth === 'basic') {
      // Use token list provider
      const response = await fetch(this.tokenListProvider);
      return response.json();
    } else {
      // Deep scan using event logs
      // This would scan for all Transfer events to the wallet
      return [];
    }
  }

  private async discoverNFTs(
    wallet: string,
    signal: AbortSignal
  ): Promise<any[]> {
    // Use NFT indexer API or scan for Transfer events
    return [];
  }

  private async getTokenBalance(
    wallet: string,
    tokenAddress: string
  ): Promise<bigint> {
    const tokenContract = new ethers.Contract(
      tokenAddress,
      ['function balanceOf(address) view returns (uint256)'],
      this.provider
    );
    return tokenContract.balanceOf(wallet);
  }

  private async estimateTokenTransferGas(
    from: string,
    token: string,
    amount: bigint
  ): Promise<bigint> {
    // Estimate gas for ERC20 transfer
    return BigInt(65000); // Typical ERC20 transfer
  }

  private async estimateNFTTransferGas(
    from: string,
    nftAddress: string,
    tokenId: string
  ): Promise<bigint> {
    // Estimate gas for NFT transfer
    return BigInt(85000); // Typical NFT transfer
  }

  private async getNativeTokenPrice(): Promise<number> {
    // Get ETH price from oracle
    return 2000; // Simplified
  }

  private async getTokenPrice(tokenAddress: string): Promise<number> {
    // Get token price from oracle or DEX
    return 1; // Simplified
  }

  private async getNFTFloorPrice(nftAddress: string): Promise<number> {
    // Get NFT floor price from marketplace API
    return 0.1; // Simplified
  }

  private async getGasPrices(): Promise<Record<string, bigint>> {
    const feeData = await this.provider.getFeeData();
    return {
      slow: feeData.gasPrice! * BigInt(80) / BigInt(100),
      standard: feeData.gasPrice!,
      fast: feeData.gasPrice! * BigInt(120) / BigInt(100)
    };
  }

  private async transferNFT(
    from: string,
    to: string,
    nftAddress: string,
    tokenId: string,
    type: string
  ): Promise<ethers.TransactionResponse> {
    // This would need to be implemented in WallyService
    throw new Error('NFT transfer not implemented');
  }

  private async updateConfig(config: ZeroOutConfig): Promise<void> {
    // Update configuration in database
  }

  private async notifyTransferComplete(
    config: ZeroOutConfig,
    planItem: TransferPlan
  ): Promise<void> {
    console.log(`✓ Transferred ${planItem.asset.symbol} (${planItem.asset.valueUSD} USD)`);
  }

  private async notifyTransferFailed(
    config: ZeroOutConfig,
    planItem: TransferPlan,
    error: any
  ): Promise<void> {
    console.error(`✗ Failed to transfer ${planItem.asset.symbol}:`, error);
  }

  private async notifyZeroOutComplete(config: ZeroOutConfig): Promise<void> {
    console.log(`✓ Zero-out complete! Transferred ${config.metadata.estimatedValue} USD in assets`);
  }
}

WALLET_ZERO_OUT Component:
import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWallet } from '../hooks/useWallet.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { 
  Wallet, 
  ArrowRight, 
  Scan, 
  AlertTriangle, 
  CheckCircle, 
  Loader,
  DollarSign,
  Gas,
  Package
} from 'lucide-react';

interface ZeroOutFormData {
  sourceWallet: string;
  targetWallet: string;
  includeNFTs: boolean;
  includeTokens: boolean;
  includeNative: boolean;
  minTokenValueUSD: number;
  gasStrategy: 'fast' | 'standard' | 'slow';
  scanDepth: 'basic' | 'deep';
  priorityOrder: 'value' | 'gas-efficient' | 'type';
  executionMode: 'immediate' | 'scheduled';
  scheduledTime?: string;
}

interface AssetDisplay {
  type: string;
  symbol: string;
  name: string;
  balance: string;
  valueUSD: number;
  gasEstimate: string;
  selected: boolean;
}

export const ZeroOutWalletComponent: React.FC = () => {
  const { address, signer } = useWallet();
  const [activeConfigs, setActiveConfigs] = useState<AutomationConfig[]>([]);
  const [showScanner, setShowScanner] = useState(false);
  const [scanning, setScanning] = useState(false);
  const [executing, setExecuting] = useState(false);
  const [discoveredAssets, setDiscoveredAssets] = useState<AssetDisplay[]>([]);
  const [executionPlan, setExecutionPlan] = useState<any[]>([]);
  const [currentStep, setCurrentStep] = useState<'setup' | 'scan' | 'review' | 'execute'>('setup');
  
  const [formData, setFormData] = useState<ZeroOutFormData>({
    sourceWallet: '',
    targetWallet: '',
    includeNFTs: true,
    includeTokens: true,
    includeNative: true,
    minTokenValueUSD: 1,
    gasStrategy: 'standard',
    scanDepth: 'basic',
    priorityOrder: 'value',
    executionMode: 'immediate'
  });

  useEffect(() => {
    if (address) {
      fetchActiveConfigs();
    }
  }, [address]);

  const fetchActiveConfigs = async () => {
    try {
      const response = await fetch(`/api/automations/${address}?type=${AutomationType.WALLET_ZERO_OUT}`);
      const data = await response.json();
      setActiveConfigs(data);
    } catch (error) {
      console.error('Failed to fetch configs:', error);
    }
  };

  const handleScan = async () => {
    setScanning(true);
    setCurrentStep('scan');

    try {
      const response = await fetch('/api/zero-out/scan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...formData,
          walletAddress: address
        })
      });

      if (response.ok) {
        const scanResult = await response.json();
        setDiscoveredAssets(scanResult.assets.map(a => ({ ...a, selected: true })));
        setCurrentStep('review');
      }
    } catch (error) {
      console.error('Scan failed:', error);
    } finally {
      setScanning(false);
    }
  };

  const toggleAssetSelection = (index: number) => {
    const updated = [...discoveredAssets];
    updated[index].selected = !updated[index].selected;
    setDiscoveredAssets(updated);
  };

  const calculateTotals = () => {
    const selected = discoveredAssets.filter(a => a.selected);
    const totalValue = selected.reduce((sum, a) => sum + a.valueUSD, 0);
    const totalGas = selected.reduce((sum, a) => sum + parseFloat(a.gasEstimate), 0);
    const estimatedGasCost = (totalGas * 0.00001).toFixed(2); // Rough estimate
    
    return {
      assetCount: selected.length,
      totalValue: totalValue.toFixed(2),
      estimatedGasCost,
      netValue: (totalValue - parseFloat(estimatedGasCost)).toFixed(2)
    };
  };

  const handleExecute = async () => {
    setExecuting(true);
    setCurrentStep('execute');

    try {
      const selectedAssets = discoveredAssets.filter(a => a.selected);
      
      const automation: Partial<AutomationConfig> = {
        type: AutomationType.WALLET_ZERO_OUT,
        walletAddress: address!,
        enabled: true,
        metadata: {
          ...formData,
          discoveredAssets: selectedAssets,
          estimatedValue: calculateTotals().totalValue,
          status: 'executing'
        }
      };

      const response = await fetch('/api/automations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(automation)
      });

      if (response.ok) {
        const result = await response.json();
        // Start monitoring execution progress
        monitorExecution(result.id);
      }
    } catch (error) {
      console.error('Execution failed:', error);
    } finally {
      setExecuting(false);
    }
  };

  const monitorExecution = async (configId: string) => {
    const interval = setInterval(async () => {
      try {
        const response = await fetch(`/api/automations/${configId}`);
        const config = await response.json();
        
        setExecutionPlan(config.metadata.executionPlan || []);
        
        if (config.metadata.status === 'completed' || config.metadata.status === 'failed') {
          clearInterval(interval);
          await fetchActiveConfigs();
        }
      } catch (error) {
        console.error('Failed to fetch execution status:', error);
      }
    }, 2000); // Poll every 2 seconds
  };

  const getAssetIcon = (type: string) => {
    switch (type) {
      case 'native':
        return '⟠'; // ETH icon
      case 'erc20':
        return '🪙';
      case 'erc721':
      case 'erc1155':
        return '🖼️';
      default:
        return '📦';
    }
  };

  const getGasStrategyInfo = (strategy: string) => {
    switch (strategy) {
      case 'fast':
        return { label: 'Fast', time: '~30 seconds', color: 'text-red-500' };
      case 'standard':
        return { label: 'Standard', time: '~3 minutes', color: 'text-yellow-500' };
      case 'slow':
        return { label: 'Slow', time: '~10 minutes', color: 'text-green-500' };
      default:
        return { label: 'Standard', time: '~3 minutes', color: 'text-yellow-500' };
    }
  };

  return (
    <div className="zero-out-wallet-container">
      <div className="header">
        <h2>Zero Out Old Wallet</h2>
        <p className="subtitle">
          Transfer all valuable assets from an old wallet to a new one
        </p>
      </div>

      {currentStep === 'setup' && (
        <div className="setup-step">
          <form onSubmit={(e) => { e.preventDefault(); handleScan(); }}>
            <div className="wallet-inputs">
              <div className="form-group">
                <label>
                  <Wallet size={16} />
                  Source Wallet (Old)
                </label>
                <input
                  type="text"
                  value={formData.sourceWallet}
                  onChange={(e) => setFormData({ ...formData, sourceWallet: e.target.value })}
                  placeholder="0x..."
                  required
                />
              </div>

              <div className="arrow-container">
                <ArrowRight size={24} />
              </div>

              <div className="form-group">
                <label>
                  <Wallet size={16} />
                  Target Wallet (New)
                </label>
                <input
                  type="text"
                  value={formData.targetWallet}
                  onChange={(e) => setFormData({ ...formData, targetWallet: e.target.value })}
                  placeholder="0x..."
                  required
                />
              </div>
            </div>

            <div className="scan-options">
              <h3>Scan Options</h3>
              
              <div className="option-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.includeNative}
                    onChange={(e) => setFormData({ ...formData, includeNative: e.target.checked })}
                  />
                  <span>Include Native Token (ETH)</span>
                </label>

                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.includeTokens}
                    onChange={(e) => setFormData({ ...formData, includeTokens: e.target.checked })}
                  />
                  <span>Include ERC20 Tokens</span>
                </label>

                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    checked={formData.includeNFTs}
                    onChange={(e) => setFormData({ ...formData, includeNFTs: e.target.checked })}
                  />
                  <span>Include NFTs</span>
                </label>
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label>Minimum Token Value (USD)</label>
                  <input
                    type="number"
                    step="0.01"
                    value={formData.minTokenValueUSD}
                    onChange={(e) => setFormData({ ...formData, minTokenValueUSD: Number(e.target.value) })}
                    min="0"
                  />
                </div>

                <div className="form-group">
                  <label>Scan Depth</label>
                  <select
                    value={formData.scanDepth}
                    onChange={(e) => setFormData({ ...formData, scanDepth: e.target.value as any })}
                  >
                    <option value="basic">Basic (Known Tokens)</option>
                    <option value="deep">Deep (All Contracts)</option>
                  </select>
                </div>
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label>Gas Strategy</label>
                  <select
                    value={formData.gasStrategy}
                    onChange={(e) => setFormData({ ...formData, gasStrategy: e.target.value as any })}
                  >
                    <option value="slow">Slow & Cheap</option>
                    <option value="standard">Standard</option>
                    <option value="fast">Fast & Expensive</option>
                  </select>
                </div>

                <div className="form-group">
                  <label>Priority Order</label>
                  <select
                    value={formData.priorityOrder}
                    onChange={(e) => setFormData({ ...formData, priorityOrder: e.target.value as any })}
                  >
                    <option value="value">Highest Value First</option>
                    <option value="gas-efficient">Most Gas Efficient</option>
                    <option value="type">By Asset Type</option>
                  </select>
                </div>
              </div>
            </div>

            <button type="submit" className="scan-button">
              <Scan size={20} />
              Scan Wallet
            </button>
          </form>
        </div>
      )}

      {currentStep === 'scan' && scanning && (
        <div className="scanning-step">
          <div className="scan-animation">
            <Loader className="spinning" size={48} />
            <h3>Scanning Wallet...</h3>
            <p>Discovering all valuable assets in {formData.sourceWallet.slice(0, 10)}...</p>
          </div>
        </div>
      )}

      {currentStep === 'review' && (
        <div className="review-step">
          <h3>Discovered Assets</h3>
          
          <div className="assets-list">
            {discoveredAssets.map((asset, index) => (
              <div 
                key={index} 
                className={`asset-item ${asset.selected ? 'selected' : ''}`}
                onClick={() => toggleAssetSelection(index)}
              >
                <div className="asset-info">
                  <span className="asset-icon">{getAssetIcon(asset.type)}</span>
                  <div>
                    <h4>{asset.symbol}</h4>
                    <p>{asset.name}</p>
                  </div>
                </div>
                
                <div className="asset-values">
                  <div className="balance">
                    <span>{asset.balance}</span>
                  </div>
                  <div className="value">
                    <DollarSign size={14} />
                    <span>{asset.valueUSD.toFixed(2)}</span>
                  </div>
                  <div className="gas">
                    <Gas size={14} />
                    <span>{(parseFloat(asset.gasEstimate) * 0.00001).toFixed(4)}</span>
                  </div>
                </div>
                
                <input
                  type="checkbox"
                  checked={asset.selected}
                  onChange={() => toggleAssetSelection(index)}
                  onClick={(e) => e.stopPropagation()}
                />
              </div>
            ))}
          </div>

          <div className="summary">
            <h4>Transfer Summary</h4>
            <div className="summary-stats">
              <div>
                <span>Assets Selected:</span>
                <strong>{calculateTotals().assetCount}</strong>
              </div>
              <div>
                <span>Total Value:</span>
                <strong>${calculateTotals().totalValue}</strong>
              </div>
              <div>
                <span>Est. Gas Cost:</span>
                <strong>${calculateTotals().estimatedGasCost}</strong>
              </div>
              <div className="net-value">
                <span>Net Value:</span>
                <strong>${calculateTotals().netValue}</strong>
              </div>
            </div>
          </div>

          <div className="action-buttons">
            <button onClick={() => setCurrentStep('setup')} className="secondary">
              Back
            </button>
            <button onClick={handleExecute} className="primary">
              Execute Transfer
            </button>
          </div>
        </div>
      )}

      {currentStep === 'execute' && (
        <div className="execution-step">
          <h3>Executing Transfers</h3>
          
          <div className="execution-progress">
            {executionPlan.map((item, index) => (
              <div key={index} className={`execution-item ${item.status}`}>
                <div className="execution-info">
                  <span className="asset-icon">{getAssetIcon(item.asset.type)}</span>
                  <span>{item.asset.symbol}</span>
                </div>
                
                <div className="execution-status">
                  {item.status === 'pending' && <Clock size={16} />}
                  {item.status === 'executing' && <Loader className="spinning" size={16} />}
                  {item.status === 'completed' && <CheckCircle size={16} />}
                  {item.status === 'failed' && <AlertTriangle size={16} />}
                  
                  {item.txHash && (
                    <a 
                      href={`https://etherscan.io/tx/${item.txHash}`} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="tx-link"
                    >
                      View TX
                    </a>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Active Zero-Out Operations */}
      {activeConfigs.length > 0 && (
        <div className="active-operations">
          <h3>Active Operations</h3>
          {activeConfigs.map((config) => (
            <div key={config.id} className="operation-card">
              <div className="operation-header">
                <h4>Zero-Out in Progress</h4>
                <span className={`status ${config.metadata.status}`}>
                  {config.metadata.status}
                </span>
              </div>
              
              <div className="operation-details">
                <p>From: {config.metadata.sourceWallet.slice(0, 10)}...</p>
                <p>To: {config.metadata.targetWallet.slice(0, 10)}...</p>
                <p>Value: ${config.metadata.estimatedValue}</p>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

***LOOK HERE
Backend Infrastructure:

```typescript name=backend/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { ethers } from 'ethers';
import jwt from 'jsonwebtoken';

interface AuthRequest extends Request {
  user?: {
    address: string;
    signature?: string;
  };
}

export const verifySignature = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { signature, message, address } = req.body;

    if (!signature || !message || !address) {
      res.status(400).json({ error: 'Missing required fields' });
      return;
    }

    // Verify the signature
    const recoveredAddress = ethers.verifyMessage(message, signature);
    
    if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
      res.status(401).json({ error: 'Invalid signature' });
      return;
    }

    req.user = { address, signature };
    next();
  } catch (error) {
    res.status(401).json({ error: 'Authentication failed' });
  }
};

export const verifyJWT = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {
      res.status(401).json({ error: 'No token provided' });
      return;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { address: string };
    req.user = { address: decoded.address };
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

export const checkWallyPermission = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const userAddress = req.user?.address;
    const targetWallet = req.params.wallet || req.body.wallet;

    if (!userAddress) {
      res.status(401).json({ error: 'Not authenticated' });
      return;
    }

    // Check if user has permission for target wallet
    // This would check against WallyWatcher contract
    const hasPermission = await checkPermissionInContract(userAddress, targetWallet);

    if (!hasPermission) {
      res.status(403).json({ error: 'No permission for this wallet' });
      return;
    }

    next();
  } catch (error) {
    res.status(500).json({ error: 'Permission check failed' });
  }
};

async function checkPermissionInContract(
  userAddress: string,
  targetWallet: string
): Promise<boolean> {
  // Implementation would check WallyWatcher contract
  return true; // Simplified
}
```
***LOOK HERE
```typescript name=backend/middleware/rateLimit.middleware.ts
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';

const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD
});

// General API rate limit
export const apiLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rate-limit:api:'
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false
});

// Strict rate limit for sensitive operations
export const strictLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rate-limit:strict:'
  }),
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // Limit each IP to 10 requests per hour
  message: 'Too many sensitive operations, please try again later.',
  standardHeaders: true,
  legacyHeaders: false
});

// Automation-specific rate limits
export const automationLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rate-limit:automation:'
  }),
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 20,
  keyGenerator: (req) => {
    // Rate limit by wallet address instead of IP
    return req.body.walletAddress || req.params.wallet || req.ip;
  }
});

// Webhook rate limit
export const webhookLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rate-limit:webhook:'
  }),
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 30
});
```
**make sure you have all of these
```typescript name=backend/routes/automations.routes.ts
import { Router } from 'express';
import { 
  createAutomation,
  getAutomations,
  updateAutomation,
  deleteAutomation,
  triggerAutomation
} from '../controllers/automations.controller.js';
import { verifyJWT, checkWallyPermission } from '../middleware/auth.middleware.js';
import { automationLimiter } from '../middleware/rateLimit.middleware.js';

const router = Router();

// Get user's automations
router.get(
  '/:wallet',
  verifyJWT,
  checkWallyPermission,
  getAutomations
);

// Create new automation
router.post(
  '/',
  verifyJWT,
  automationLimiter,
  checkWallyPermission,
  createAutomation
);

// Update automation
router.patch(
  '/:id',
  verifyJWT,
  checkWallyPermission,
  updateAutomation
);

// Delete automation
router.delete(
  '/:id',
  verifyJWT,
  checkWallyPermission,
  deleteAutomation
);

// Manually trigger automation
router.post(
  '/:id/trigger',
  verifyJWT,
  automationLimiter,
  checkWallyPermission,
  triggerAutomation
);

export default router;
```
**LOOK HERE
```typescript name=backend/routes/webhooks.routes.ts
import { Router } from 'express';
import { 
  handleTransactionWebhook,
  handlePriceWebhook,
  handleGasWebhook,
  handleChainlinkWebhook
} from '../controllers/webhooks.controller.js';
import { webhookLimiter } from '../middleware/rateLimit.middleware.js';
import { verifyWebhookSignature } from '../middleware/webhook.middleware.js';

const router = Router();

// Transaction monitoring webhooks
router.post(
  '/transaction',
  webhookLimiter,
  verifyWebhookSignature('alchemy'),
  handleTransactionWebhook
);

// Price update webhooks
router.post(
  '/price',
  webhookLimiter,
  verifyWebhookSignature('coingecko'),
  handlePriceWebhook
);

// Gas price webhooks
router.post(
  '/gas',
  webhookLimiter,
  verifyWebhookSignature('ethgasstation'),
  handleGasWebhook
);

// Chainlink oracle webhooks
router.post(
  '/chainlink',
  webhookLimiter,
  verifyWebhookSignature('chainlink'),
  handleChainlinkWebhook
);

export default router;
```

```typescript name=backend/controllers/automations.controller.ts
import { Request, Response } from 'express';
import { AutomationService } from '../services/AutomationService.js';
import { DatabaseService } from '../services/DatabaseService.js';
import { AutomationConfig, AutomationType } from '../../shared/types.js';

const automationService = new AutomationService();
const dbService = new DatabaseService();

export const createAutomation = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const automationData: Partial<AutomationConfig> = req.body;
    
    // Validate automation type
    if (!Object.values(AutomationType).includes(automationData.type!)) {
      res.status(400).json({ error: 'Invalid automation type' });
      return;
    }

    // Create automation in database
    const automation = await dbService.createAutomation(automationData);
    
    // Start automation if enabled
    if (automation.enabled) {
      await automationService.startAutomation(automation);
    }

    res.status(201).json(automation);
  } catch (error) {
    console.error('Error creating automation:', error);
    res.status(500).json({ error: 'Failed to create automation' });
  }
};

export const getAutomations = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const wallet = req.params.wallet;
    const type = req.query.type as AutomationType | undefined;

    const automations = await dbService.getAutomations(wallet, type);
    res.json(automations);
  } catch (error) {
    console.error('Error fetching automations:', error);
    res.status(500).json({ error: 'Failed to fetch automations' });
  }
};

export const updateAutomation = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const automation = await dbService.updateAutomation(id, updates);
    
    if (!automation) {
      res.status(404).json({ error: 'Automation not found' });
      return;
    }

    // Restart automation if it was enabled
    if (automation.enabled) {
      await automationService.restartAutomation(automation);
    } else {
      await automationService.stopAutomation(automation.id);
    }

    res.json(automation);
  } catch (error) {
    console.error('Error updating automation:', error);
    res.status(500).json({ error: 'Failed to update automation' });
  }
};

export const deleteAutomation = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    // Stop automation first
    await automationService.stopAutomation(id);

    // Delete from database
    const deleted = await dbService.deleteAutomation(id);
    
    if (!deleted) {
      res.status(404).json({ error: 'Automation not found' });
      return;
    }

    res.status(204).send();
  } catch (error) {
    console.error('Error deleting automation:', error);
    res.status(500).json({ error: 'Failed to delete automation' });
  }
};

export const triggerAutomation = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    const automation = await dbService.getAutomation(id);
    
    if (!automation) {
      res.status(404).json({ error: 'Automation not found' });
      return;
    }

    // Manually trigger the automation
    await automationService.triggerManually(automation);

    res.json({ message: 'Automation triggered successfully' });
  } catch (error) {
    console.error('Error triggering automation:', error);
    res.status(500).json({ error: 'Failed to trigger automation' });
  }
};
```

```typescript name=backend/services/AutomationService.ts
import { ethers } from 'ethers';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { WallyService } from './WallyService.js';
import { AutoSaveAutomation } from '../automations/AutoSaveAutomation.js';
import { SubscriptionAutomation } from '../automations/SubscriptionAutomation.js';
import { BillPaymentAutomation } from '../automations/BillPaymentAutomation.js';
import { DCAAutomation } from '../automations/DCAAutomation.js';
import { EmergencyFundAutomation } from '../automations/EmergencyFundAutomation.js';
import { CharityDonationAutomation } from '../automations/CharityDonationAutomation.js';
import { MultiWalletConsolidationAutomation } from '../automations/MultiWalletConsolidationAutomation.js';
import { ZeroOutWalletAutomation } from '../automations/ZeroOutWalletAutomation.js';

export class AutomationService {
  private automations: Map<string, any> = new Map();
  private wallyService: WallyService;
  private provider: ethers.Provider;

  constructor() {
    this.provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
    this.wallyService = new WallyService(
      process.env.WATCHER_ADDRESS!,
      process.env.WRITER_ADDRESS!,
      [], // ABIs would be loaded from files
      [],
      process.env.RPC_URL!,
      process.env.PRIVATE_KEY!
    );

    this.initializeAutomationEngines();
  }

  private initializeAutomationEngines(): void {
    // Initialize each automation engine
    this.automations.set(
      AutomationType.AUTO_SAVE,
      new AutoSaveAutomation(this.wallyService, this.provider)
    );
    
    this.automations.set(
      AutomationType.SUBSCRIPTION,
      new SubscriptionAutomation(this.wallyService)
    );
    
    this.automations.set(
      AutomationType.BILL_PAYMENT,
      new BillPaymentAutomation(this.wallyService)
    );
    
    this.automations.set(
      AutomationType.DCA_INVESTMENT,
      new DCAAutomation(
        this.wallyService,
        this.provider,
        process.env.PRICE_ORACLE_ADDRESS!
      )
    );
    
    this.automations.set(
      AutomationType.EMERGENCY_FUND,
      new EmergencyFundAutomation(this.wallyService, this.provider)
    );
    
    this.automations.set(
      AutomationType.CHARITY_DONATION,
      new CharityDonationAutomation(this.wallyService, this.provider)
    );
    
    this.automations.set(
      AutomationType.WALLET_CONSOLIDATION,
      new MultiWalletConsolidationAutomation(
        this.wallyService,
        this.provider,
        process.env.PRICE_ORACLE_ADDRESS!
      )
    );
    
    this.automations.set(
      AutomationType.WALLET_ZERO_OUT,
      new ZeroOutWalletAutomation(
        this.wallyService,
        this.provider,
        process.env.TOKEN_LIST_URL!,
        process.env.PRICE_ORACLE_ADDRESS!
      )
    );
  }

  async startAutomation(config: AutomationConfig): Promise<void> {
    const engine = this.automations.get(config.type);
    if (!engine) {
      throw new Error(`Unknown automation type: ${config.type}`);
    }

    await engine.start(config);
  }

  async stopAutomation(automationId: string): Promise<void> {
    // Stop automation across all engines
    for (const engine of this.automations.values()) {
      if (engine.stop) {
        engine.stop(automationId);
      }
    }
  }

  async restartAutomation(config: AutomationConfig): Promise<void> {
    await this.stopAutomation(config.id);
    await this.startAutomation(config);
  }

  async triggerManually(config: AutomationConfig): Promise<void> {
    const engine = this.automations.get(config.type);
    if (!engine) {
      throw new Error(`Unknown automation type: ${config.type}`);
    }

    // Different automation types have different manual trigger methods
    switch (config.type) {
      case AutomationType.AUTO_SAVE:
      case AutomationType.EMERGENCY_FUND:
        await engine.checkAndExecute(config);
        break;
      case AutomationType.SUBSCRIPTION:
      case AutomationType.BILL_PAYMENT:
        await engine.processPayment(config);
        break;
      case AutomationType.DCA_INVESTMENT:
        await engine.executeDCA(config);
        break;
      case AutomationType.CHARITY_DONATION:
        await engine.processRecurringDonation(config);
        break;
      case AutomationType.WALLET_CONSOLIDATION:
        await engine.manualConsolidation(config.id);
        break;
      case AutomationType.WALLET_ZERO_OUT:
        await engine.executeZeroOut(config);
        break;
    }
  }
}
```

```typescript name=backend/services/DatabaseService.ts
import { PrismaClient } from '@prisma/client';
import { AutomationConfig, AutomationType } from '../../shared/types.js';
import { v4 as uuidv4 } from 'uuid';

export class DatabaseService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async createAutomation(
    data: Partial<AutomationConfig>
  ): Promise<AutomationConfig> {
    const automation = await this.prisma.automation.create({
      data: {
        id: uuidv4(),
        type: data.type!,
        walletAddress: data.walletAddress!,
        enabled: data.enabled ?? true,
        metadata: data.metadata as any,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    });

    return this.mapToAutomationConfig(automation);
  }

  async getAutomations(
    walletAddress: string,
    type?: AutomationType
  ): Promise<AutomationConfig[]> {
    const where: any = { walletAddress };
    if (type) {
      where.type = type;
    }

    const automations = await this.prisma.automation.findMany({
      where,
      orderBy: { createdAt: 'desc' }
    });

    return automations.map(this.mapToAutomationConfig);
  }

  async getAutomation(id: string): Promise<AutomationConfig | null> {
    const automation = await this.prisma.automation.findUnique({
      where: { id }
    });

    return automation ? this.mapToAutomationConfig(automation) : null;
  }

  async updateAutomation(
    id: string,
    updates: Partial<AutomationConfig>
  ): Promise<AutomationConfig | null> {
    try {
      const automation = await this.prisma.automation.update({
        where: { id },
        data: {
          ...updates,
          metadata: updates.metadata as any,
          updatedAt: new Date()
        }
      });

      return this.mapToAutomationConfig(automation);
    } catch (error) {
      return null;
    }
  }

  async deleteAutomation(id: string): Promise<boolean> {
    try {
      await this.prisma.automation.delete({
        where: { id }
      });
      return true;
    } catch (error) {
      return false;
    }
  }

  async getActiveAutomations(): Promise<AutomationConfig[]> {
    const automations = await this.prisma.automation.findMany({
      where: { enabled: true }
    });

    return automations.map(this.mapToAutomationConfig);
  }

  private mapToAutomationConfig(dbAutomation: any): AutomationConfig {
    return {
      id: dbAutomation.id,
      type: dbAutomation.type as AutomationType,
      walletAddress: dbAutomation.walletAddress,
      enabled: dbAutomation.enabled,
      createdAt: dbAutomation.createdAt.getTime(),
      updatedAt: dbAutomation.updatedAt.getTime(),
      metadata: dbAutomation.metadata
    };
  }
}
```

```typescript name=backend/helpers/gasEstimator.ts
import { ethers } from 'ethers';

interface GasEstimate {
  gasLimit: bigint;
  gasPrice: bigint;
  maxFeePerGas?: bigint;
  maxPriorityFeePerGas?: bigint;
  estimatedCost: bigint;
  estimatedCostUSD: number;
}

export class GasEstimator {
  private provider: ethers.Provider;
  private ethPriceUSD: number = 2000; // Default, should be fetched from oracle

  constructor(provider: ethers.Provider) {
    this.provider = provider;
  }

  async estimateTransfer(
    from: string,
    to: string,
    value: bigint,
    data?: string
  ): Promise<GasEstimate> {
    try {
      // Estimate gas limit
      const gasLimit = await this.provider.estimateGas({
        from,
        to,
        value,
        data
      });

      // Get current gas prices
      const feeData = await this.provider.getFeeData();
      
      if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
        // EIP-1559 transaction
        const estimatedCost = gasLimit * feeData.maxFeePerGas;
        
        return {
          gasLimit,
          gasPrice: feeData.gasPrice!,
          maxFeePerGas: feeData.maxFeePerGas,
          maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,
          estimatedCost,
          estimatedCostUSD: this.calculateUSDCost(estimatedCost)
        };
      } else {
        // Legacy transaction
        const estimatedCost = gasLimit * feeData.gasPrice!;
        
        return {
          gasLimit,
          gasPrice: feeData.gasPrice!,
          estimatedCost,
          estimatedCostUSD: this.calculateUSDCost(estimatedCost)
        };
      }
    } catch (error) {
      console.error('Gas estimation failed:', error);
      throw error;
    }
  }

  async estimateBatchTransfer(
    transfers: Array<{ from: string; to: string; value: bigint; data?: string }>
  ): Promise<GasEstimate> {
    // Estimate gas for batch transfer contract call
    // This would depend on the specific batch transfer implementation
    const baseGas = BigInt(21000); // Base transfer cost
    const perTransferGas = BigInt(30000); // Additional gas per transfer
    
    const gasLimit = baseGas + (perTransferGas * BigInt(transfers.length));
    const feeData = await this.provider.getFeeData();
    const estimatedCost = gasLimit * feeData.gasPrice!;
    
    return {
      gasLimit,
      gasPrice: feeData.gasPrice!,
      estimatedCost,
      estimatedCostUSD: this.calculateUSDCost(estimatedCost)
    };
  }

  async getGasPriceRecommendations(): Promise<{
    slow: GasEstimate;
    standard: GasEstimate;
    fast: GasEstimate;
  }> {
    const feeData = await this.provider.getFeeData();
    const baseGasLimit = BigInt(21000); // Standard transfer
    
    const slowGasPrice = (feeData.gasPrice! * BigInt(80)) / BigInt(100);
    const standardGasPrice = feeData.gasPrice!;
    const fastGasPrice = (feeData.gasPrice! * BigInt(120)) / BigInt(100);
    
    return {
      slow: {
        gasLimit: baseGasLimit,
        gasPrice: slowGasPrice,
        estimatedCost: baseGasLimit * slowGasPrice,
        estimatedCostUSD: this.calculateUSDCost(baseGasLimit * slowGasPrice)
      },
      standard: {
        gasLimit: baseGasLimit,
        gasPrice: standardGasPrice,
        estimatedCost: baseGasLimit * standardGasPrice,
        estimatedCostUSD: this.calculateUSDCost(baseGasLimit * standardGasPrice)
      },
      fast: {
        gasLimit: baseGasLimit,
        gasPrice: fastGasPrice,
        estimatedCost: baseGasLimit * fastGasPrice,
        estimatedCostUSD: this.calculateUSDCost(baseGasLimit * fastGasPrice)
      }
    };
  }

  private calculateUSDCost(weiCost: bigint): number {
    const ethCost = parseFloat(ethers.formatEther(weiCost));
    return ethCost * this.ethPriceUSD;
  }

  setEthPrice(priceUSD: number): void {
    this.ethPriceUSD = priceUSD;
  }
}
```

```typescript name=backend/helpers/tokenPriceOracle.ts
import { ethers } from 'ethers';
import axios from 'axios';

interface TokenPrice {
  address: string;
  symbol: string;
  price: number;
  timestamp: number;
}

export class TokenPriceOracle {
  private cache: Map<string, TokenPrice> = new Map();
  private cacheTimeout: number = 5 * 60 * 1000; // 5 minutes
  private chainlinkOracle?: ethers.Contract;

  constructor(
    private provider: ethers.Provider,
    chainlinkOracleAddress?: string
  ) {
    if (chainlinkOracleAddress) {
      this.chainlinkOracle = new ethers.Contract(
        chainlinkOracleAddress,
        [
          'function latestRoundData() view returns (uint80 roundId, int256 price, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)'
        ],
        provider
      );
    }
  }

  async getTokenPrice(tokenAddress: string): Promise<number> {
    // Check cache first
    const cached = this.cache.get(tokenAddress.toLowerCase());
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.price;
    }

    // Special case for ETH
    if (tokenAddress === ethers.ZeroAddress) {
      return this.getETHPrice();
    }

    try {
      // Try Chainlink first
      if (this.chainlinkOracle) {
        const price = await this.getChainlinkPrice(tokenAddress);
        if (price > 0) return price;
      }

      // Fallback to CoinGecko API
      const price = await this.getCoinGeckoPrice(tokenAddress);
      
      // Cache the result
      this.cache.set(tokenAddress.toLowerCase(), {
        address: tokenAddress,
        symbol: '',
        price,
        timestamp: Date.now()
      });

      return price;
    } catch (error) {


LOOK HERE FOR SERVICE FILES (**REMEMBER TO REPLACE ANY INCORRECT IMPORTS AND INCLUDE .js OR .jsx IN LOCALLY IMPORTED FILES FOR ESM COMPLIANCE**)
Looking at what I've provided, I included the main automation classes but not the separate service and helper files. Let me provide these missing service and helper files for each automation type:

### Auto-Save Service & Helpers

```typescript name=backend/services/autoSaveService.ts
import { ethers } from 'ethers';
import { AutoSaveAutomation } from '../automations/AutoSaveAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';
import { validateAutoSaveConfig, calculateOptimalThreshold } from '../helpers/autoSaveHelpers.js';

export class AutoSaveService {
  private automation: AutoSaveAutomation;
  private dbService: DatabaseService;

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    dbService: DatabaseService
  ) {
    this.automation = new AutoSaveAutomation(wallyService, provider);
    this.dbService = dbService;
  }

  async createAutoSave(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate configuration
    const validation = validateAutoSaveConfig(config.metadata);
    if (!validation.valid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // Calculate optimal threshold if not provided
    if (!config.metadata.thresholdAmount) {
      config.metadata.thresholdAmount = await calculateOptimalThreshold(
        config.walletAddress!,
        config.metadata.tokenAddress
      );
    }

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Start automation
    await this.automation.start(savedConfig);

    return savedConfig;
  }

  async updateThreshold(
    configId: string,
    newThreshold: string
  ): Promise<AutomationConfig> {
    const config = await this.dbService.getAutomation(configId);
    if (!config) throw new Error('Configuration not found');

    config.metadata.thresholdAmount = newThreshold;
    
    const updated = await this.dbService.updateAutomation(configId, config);
    
    // Restart automation with new config
    this.automation.stop(configId);
    await this.automation.start(updated!);

    return updated!;
  }

  async getAutoSaveStats(walletAddress: string): Promise<{
    totalSaved: string;
    savingsCount: number;
    averageSaving: string;
    lastSaving: Date | null;
  }> {
    // Fetch all auto-save configs for wallet
    const configs = await this.dbService.getAutomations(walletAddress, 'AUTO_SAVE');
    
    let totalSaved = BigInt(0);
    let savingsCount = 0;
    let lastSaving: Date | null = null;

    for (const config of configs) {
      const history = config.metadata.savingsHistory || [];
      for (const saving of history) {
        totalSaved += BigInt(saving.amount);
        savingsCount++;
        const savingDate = new Date(saving.timestamp);
        if (!lastSaving || savingDate > lastSaving) {
          lastSaving = savingDate;
        }
      }
    }

    return {
      totalSaved: totalSaved.toString(),
      savingsCount,
      averageSaving: savingsCount > 0 ? (totalSaved / BigInt(savingsCount)).toString() : '0',
      lastSaving
    };
  }

  async predictNextSaving(configId: string): Promise<{
    estimatedDate: Date;
    estimatedAmount: string;
    confidence: number;
  }> {
    const config = await this.dbService.getAutomation(configId);
    if (!config) throw new Error('Configuration not found');

    // Analyze historical patterns
    const history = config.metadata.savingsHistory || [];
    if (history.length < 3) {
      return {
        estimatedDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 1 week
        estimatedAmount: '0',
        confidence: 0.1
      };
    }

    // Calculate average interval and amount
    let totalInterval = 0;
    let totalAmount = BigInt(0);
    
    for (let i = 1; i < history.length; i++) {
      totalInterval += history[i].timestamp - history[i - 1].timestamp;
      totalAmount += BigInt(history[i].amount);
    }

    const avgInterval = totalInterval / (history.length - 1);
    const avgAmount = totalAmount / BigInt(history.length);
    const lastSaving = history[history.length - 1];

    return {
      estimatedDate: new Date(lastSaving.timestamp + avgInterval),
      estimatedAmount: avgAmount.toString(),
      confidence: Math.min(0.9, history.length * 0.1)
    };
  }
}
```

```typescript name=backend/helpers/autoSaveHelpers.ts
import { ethers } from 'ethers';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export function validateAutoSaveConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.targetSavingsAddress || !ethers.isAddress(metadata.targetSavingsAddress)) {
    errors.push('Invalid target savings address');
  }

  if (!metadata.tokenAddress || !ethers.isAddress(metadata.tokenAddress)) {
    errors.push('Invalid token address');
  }

  const threshold = parseFloat(metadata.thresholdAmount || '0');
  if (threshold <= 0) {
    errors.push('Threshold amount must be greater than 0');
  }

  const checkInterval = parseInt(metadata.checkInterval || '0');
  if (checkInterval < 300) { // Minimum 5 minutes
    errors.push('Check interval must be at least 300 seconds');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export async function calculateOptimalThreshold(
  walletAddress: string,
  tokenAddress: string,
  provider?: ethers.Provider
): Promise<string> {
  // Analyze wallet's transaction history to determine optimal threshold
  // This is a simplified version - real implementation would analyze on-chain data
  
  // Default thresholds based on token type
  if (tokenAddress === ethers.ZeroAddress) {
    // ETH - suggest keeping 0.1 ETH for gas
    return ethers.parseEther('0.1').toString();
  } else {
    // Stablecoins - suggest keeping $50
    return ethers.parseUnits('50', 18).toString();
  }
}

export function calculateSavingsRate(
  history: Array<{ amount: string; timestamp: number }>
): {
  dailyRate: string;
  weeklyRate: string;
  monthlyRate: string;
} {
  if (history.length < 2) {
    return {
      dailyRate: '0',
      weeklyRate: '0',
      monthlyRate: '0'
    };
  }

  // Calculate total saved and time period
  let totalSaved = BigInt(0);
  for (const saving of history) {
    totalSaved += BigInt(saving.amount);
  }

  const firstSaving = history[0];
  const lastSaving = history[history.length - 1];
  const timePeriodMs = lastSaving.timestamp - firstSaving.timestamp;
  const days = timePeriodMs / (1000 * 60 * 60 * 24);

  if (days === 0) {
    return {
      dailyRate: totalSaved.toString(),
      weeklyRate: totalSaved.toString(),
      monthlyRate: totalSaved.toString()
    };
  }

  const dailyRate = totalSaved / BigInt(Math.max(1, Math.floor(days)));
  
  return {
    dailyRate: dailyRate.toString(),
    weeklyRate: (dailyRate * BigInt(7)).toString(),
    monthlyRate: (dailyRate * BigInt(30)).toString()
  };
}

export function shouldTriggerSaving(
  currentBalance: bigint,
  threshold: bigint,
  minSavingAmount: bigint = BigInt(0)
): boolean {
  if (currentBalance <= threshold) {
    return false;
  }

  const excess = currentBalance - threshold;
  return excess >= minSavingAmount;
}
```

### Subscription Management Service & Helpers

```typescript name=backend/services/subscriptionManagementService.ts
import { SubscriptionAutomation } from '../automations/SubscriptionAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';
import { 
  validateSubscriptionConfig,
  calculateNextPaymentDate,
  checkSubscriptionHealth
} from '../helpers/subscriptionManagementHelpers.js';

export class SubscriptionManagementService {
  private automation: SubscriptionAutomation;
  private dbService: DatabaseService;

  constructor(wallyService: WallyService, dbService: DatabaseService) {
    this.automation = new SubscriptionAutomation(wallyService);
    this.dbService = dbService;
  }

  async createSubscription(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate configuration
    const validation = validateSubscriptionConfig(config.metadata);
    if (!validation.valid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // Calculate next payment date
    config.metadata.nextPaymentDate = calculateNextPaymentDate(
      config.metadata.frequency,
      config.metadata.dayOfMonth
    );

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Start automation
    await this.automation.start(savedConfig);

    return savedConfig;
  }

  async getUpcomingPayments(
    walletAddress: string,
    days: number = 30
  ): Promise<Array<{
    subscription: AutomationConfig;
    paymentDate: Date;
    amount: string;
  }>> {
    const subscriptions = await this.dbService.getAutomations(walletAddress, 'SUBSCRIPTION');
    const upcoming = [];
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + days);

    for (const sub of subscriptions) {
      if (!sub.enabled) continue;

      const paymentDate = new Date(sub.metadata.nextPaymentDate);
      if (paymentDate <= endDate) {
        upcoming.push({
          subscription: sub,
          paymentDate,
          amount: sub.metadata.amount
        });
      }
    }

    return upcoming.sort((a, b) => a.paymentDate.getTime() - b.paymentDate.getTime());
  }

  async pauseSubscription(
    configId: string,
    until?: Date
  ): Promise<AutomationConfig> {
    const config = await this.dbService.getAutomation(configId);
    if (!config) throw new Error('Subscription not found');

    config.enabled = false;
    if (until) {
      config.metadata.pausedUntil = until.getTime();
    }

    const updated = await this.dbService.updateAutomation(configId, config);
    this.automation.stop(configId);

    return updated!;
  }

  async resumeSubscription(configId: string): Promise<AutomationConfig> {
    const config = await this.dbService.getAutomation(configId);
    if (!config) throw new Error('Subscription not found');

    config.enabled = true;
    delete config.metadata.pausedUntil;

    // Recalculate next payment date
    config.metadata.nextPaymentDate = calculateNextPaymentDate(
      config.metadata.frequency,
      config.metadata.dayOfMonth
    );

    const updated = await this.dbService.updateAutomation(configId, config);
    await this.automation.start(updated!);

    return updated!;
  }

  async getSubscriptionHealth(configId: string): Promise<{
    status: 'healthy' | 'warning' | 'critical';
    issues: string[];
    recommendations: string[];
  }> {
    const config = await this.dbService.getAutomation(configId);
    if (!config) throw new Error('Subscription not found');

    return checkSubscriptionHealth(config);
  }

  async updatePaymentMethod(
    configId: string,
    newTokenAddress: string
  ): Promise<AutomationConfig> {
    const config = await this.dbService.getAutomation(configId);
    if (!config) throw new Error('Subscription not found');

    config.metadata.tokenAddress = newTokenAddress;
    
    const updated = await this.dbService.updateAutomation(configId, config);
    
    // Restart automation
    this.automation.stop(configId);
    await this.automation.start(updated!);

    return updated!;
  }
}
```

```typescript name=backend/helpers/subscriptionManagementHelpers.ts
import { ethers } from 'ethers';
import { AutomationConfig } from '../../shared/types.js';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export function validateSubscriptionConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.serviceName || metadata.serviceName.trim().length === 0) {
    errors.push('Service name is required');
  }

  if (!metadata.recipientAddress || !ethers.isAddress(metadata.recipientAddress)) {
    errors.push('Invalid recipient address');
  }

  const amount = parseFloat(metadata.amount || '0');
  if (amount <= 0) {
    errors.push('Amount must be greater than 0');
  }

  if (!['monthly', 'yearly'].includes(metadata.frequency)) {
    errors.push('Invalid frequency');
  }

  const dayOfMonth = parseInt(metadata.dayOfMonth || '0');
  if (dayOfMonth < 1 || dayOfMonth > 28) {
    errors.push('Day of month must be between 1 and 28');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export function calculateNextPaymentDate(
  frequency: 'monthly' | 'yearly',
  dayOfMonth: number,
  fromDate: Date = new Date()
): number {
  const nextDate = new Date(fromDate);
  nextDate.setDate(dayOfMonth);

  // If the day has already passed this month, move to next period
  if (nextDate <= fromDate) {
    if (frequency === 'monthly') {
      nextDate.setMonth(nextDate.getMonth() + 1);
    } else {
      nextDate.setFullYear(nextDate.getFullYear() + 1);
    }
  }

  return nextDate.getTime();
}

export function checkSubscriptionHealth(
  config: AutomationConfig
): {
  status: 'healthy' | 'warning' | 'critical';
  issues: string[];
  recommendations: string[];
} {
  const issues: string[] = [];
  const recommendations: string[] = [];
  let status: 'healthy' | 'warning' | 'critical' = 'healthy';

  // Check if payment is overdue
  const now = Date.now();
  if (config.metadata.nextPaymentDate < now) {
    issues.push('Payment is overdue');
    status = 'critical';
  }

  // Check payment history for failures
  const recentFailures = (config.metadata.paymentHistory || [])
    .filter((p: any) => p.status === 'failed' && now - p.timestamp < 30 * 24 * 60 * 60 * 1000)
    .length;

  if (recentFailures > 2) {
    issues.push(`${recentFailures} failed payments in the last 30 days`);
    status = 'critical';
    recommendations.push('Check wallet balance and permissions');
  } else if (recentFailures > 0) {
    issues.push(`${recentFailures} failed payment(s) recently`);
    status = 'warning';
  }

  // Check if subscription is paused
  if (!config.enabled) {
    issues.push('Subscription is paused');
    if (status === 'healthy') status = 'warning';
  }

  // Check upcoming expiry
  const daysUntilNext = Math.floor((config.metadata.nextPaymentDate - now) / (24 * 60 * 60 * 1000));
  if (daysUntilNext <= 3 && daysUntilNext >= 0) {
    recommendations.push(`Payment due in ${daysUntilNext} days - ensure sufficient balance`);
  }

  return { status, issues, recommendations };
}

export function calculateSubscriptionCost(
  amount: string,
  frequency: 'monthly' | 'yearly',
  period: 'monthly' | 'yearly'
): string {
  const baseAmount = BigInt(amount);
  
  if (frequency === period) {
    return amount;
  }

  if (frequency === 'monthly' && period === 'yearly') {
    return (baseAmount * BigInt(12)).toString();
  }

  if (frequency === 'yearly' && period === 'monthly') {
    return (baseAmount / BigInt(12)).toString();
  }

  return amount;
}

export function groupSubscriptionsByCategory(
  subscriptions: AutomationConfig[]
): Map<string, AutomationConfig[]> {
  const grouped = new Map<string, AutomationConfig[]>();

  for (const sub of subscriptions) {
    const category = sub.metadata.category || 'other';
    if (!grouped.has(category)) {
      grouped.set(category, []);
    }
    grouped.get(category)!.push(sub);
  }

  return grouped;
}
```

### Bill Payment Service & Helpers

```typescript name=backend/services/billPaymentService.ts
import { BillPaymentAutomation } from '../automations/BillPaymentAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';
import {
  validateBillConfig,
  calculateDueDate,
  analyzeBillPattern,
  estimateNextBillAmount
} from '../helpers/billPaymentHelpers.js';

export class BillPaymentService {
  private automation: BillPaymentAutomation;
  private dbService: DatabaseService;

  constructor(wallyService: WallyService, dbService: DatabaseService) {
    this.automation = new BillPaymentAutomation(wallyService);
    this.dbService = dbService;
  }

  async registerBill(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate configuration
    const validation = validateBillConfig(config.metadata);
    if (!validation.valid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Register with automation engine
    await this.automation.registerBill(savedConfig);

    return savedConfig;
  }

  async getOverdueBills(walletAddress: string): Promise<AutomationConfig[]> {
    const bills = await this.dbService.getAutomations(walletAddress, 'BILL_PAYMENT');
    const overdue = [];
    const today = new Date();

    for (const bill of bills) {
      const dueDate = calculateDueDate(bill.metadata.dueDay);
      if (dueDate < today && !this.isPaidThisMonth(bill)) {
        overdue.push(bill);
      }
    }

    return overdue;
  }

  async payBill(
    billId: string,
    amount: string,
    userAddress: string
  ): Promise<{ success: boolean; txHash?: string; error?: string }> {
    try {
      await this.automation.processManualPayment(billId, amount, userAddress);
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Payment failed'
      };
    }
  }

  async analyzeBillHistory(
    billId: string
  ): Promise<{
    averageAmount: string;
    pattern: 'stable' | 'increasing' | 'decreasing' | 'variable';
    prediction: { amount: string; confidence: number };
  }> {
    const bill = await this.dbService.getAutomation(billId);
    if (!bill) throw new Error('Bill not found');

    const pattern = analyzeBillPattern(bill.metadata.paymentHistory || []);
    const prediction = estimateNextBillAmount(bill.metadata.paymentHistory || []);

    return {
      averageAmount: bill.metadata.averageAmount,
      pattern,
      prediction
    };
  }

  async setBillReminder(
    billId: string,
    daysBefore: number
  ): Promise<AutomationConfig> {
    const bill = await this.dbService.getAutomation(billId);
    if (!bill) throw new Error('Bill not found');

    bill.metadata.reminderDays = daysBefore;
    
    return await this.dbService.updateAutomation(billId, bill) || bill;
  }

  async getBillCalendar(
    walletAddress: string,
    month: number,
    year: number
  ): Promise<Map<number, AutomationConfig[]>> {
    const bills = await this.dbService.getAutomations(walletAddress, 'BILL_PAYMENT');
    const calendar = new Map<number, AutomationConfig[]>();

    for (const bill of bills) {
      const day = bill.metadata.dueDay;
      if (!calendar.has(day)) {
        calendar.set(day, []);
      }
      calendar.get(day)!.push(bill);
    }

    return calendar;
  }

  private isPaidThisMonth(bill: AutomationConfig): boolean {
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    
    const lastPayment = bill.metadata.paymentHistory?.slice(-1)[0];
    if (!lastPayment) return false;

    const paymentDate = new Date(lastPayment.timestamp);
    return paymentDate.getMonth() === currentMonth && 
           paymentDate.getFullYear() === currentYear;
  }
}
```

```typescript name=backend/helpers/billPaymentHelpers.ts
import { ethers } from 'ethers';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

interface PaymentRecord {
  amount: string;
  timestamp: number;
  status: 'success' | 'failed';
}

export function validateBillConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.providerName || metadata.providerName.trim().length === 0) {
    errors.push('Provider name is required');
  }

  if (!metadata.recipientAddress || !ethers.isAddress(metadata.recipientAddress)) {
    errors.push('Invalid recipient address');
  }

  if (!metadata.billType) {
    errors.push('Bill type is required');
  }

  const dueDay = parseInt(metadata.dueDay || '0');
  if (dueDay < 1 || dueDay > 28) {
    errors.push('Due day must be between 1 and 28');
  }

  const reminderDays = parseInt(metadata.reminderDays || '0');
  if (reminderDays < 0 || reminderDays > 30) {
    errors.push('Reminder days must be between 0 and 30');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export function calculateDueDate(dueDay: number, fromDate: Date = new Date()): Date {
  const dueDate = new Date(fromDate);
  dueDate.setDate(dueDay);

  // If the due day has passed this month, use next month
  if (dueDate <= fromDate) {
    dueDate.setMonth(dueDate.getMonth() + 1);
  }

  return dueDate;
}

export function analyzeBillPattern(
  history: PaymentRecord[]
): 'stable' | 'increasing' | 'decreasing' | 'variable' {
  if (history.length < 3) return 'stable';

  const amounts = history.map(h => parseFloat(ethers.formatUnits(h.amount, 18)));
  let increasing = 0;
  let decreasing = 0;
  let totalVariance = 0;

  for (let i = 1; i < amounts.length; i++) {
    const change = amounts[i] - amounts[i - 1];
    const percentChange = Math.abs(change) / amounts[i - 1];
    
    if (change > 0) increasing++;
    else if (change < 0) decreasing++;
    
    totalVariance += percentChange;
  }

  const avgVariance = totalVariance / (amounts.length - 1);

  // High variance indicates variable pattern
  if (avgVariance > 0.2) return 'variable';

  // Consistent direction indicates trend
  if (increasing > amounts.length * 0.7) return 'increasing';
  if (decreasing > amounts.length * 0.7) return 'decreasing';

  return 'stable';
}

export function estimateNextBillAmount(
  history: PaymentRecord[]
): { amount: string; confidence: number } {
  if (history.length === 0) {
    return { amount: '0', confidence: 0 };
  }

  if (history.length === 1) {
    return { amount: history[0].amount, confidence: 0.5 };
  }

  const amounts = history.map(h => BigInt(h.amount));
  
  // Simple moving average for stable bills
  const pattern = analyzeBillPattern(history);
  
  if (pattern === 'stable') {
    // Use simple average
    const sum = amounts.reduce((a, b) => a + b, BigInt(0));
    const avg = sum / BigInt(amounts.length);
    return { amount: avg.toString(), confidence: 0.8 };
  }

  // For trending bills, use weighted average favoring recent
  let weightedSum = BigInt(0);
  let totalWeight = 0;
  
  for (let i = 0; i < amounts.length; i++) {
    const weight = i + 1; // More recent = higher weight
    weightedSum += amounts[i] * BigInt(weight);
    totalWeight += weight;
  }

  const weightedAvg = weightedSum / BigInt(totalWeight);
  
  // Lower confidence for variable patterns
  const confidence = pattern === 'variable' ? 0.4 : 0.6;
  
  return { amount: weightedAvg.toString(), confidence };
}

export function categorizeBillsByType(
  bills: any[]
): Map<string, any[]> {
  const categorized = new Map<string, any[]>();
  
  for (const bill of bills) {
    const type = bill.metadata.billType || 'other';
    if (!categorized.has(type)) {
      categorized.set(type, []);
    }
    categorized.get(type)!.push(bill);
  }

  return categorized;
}

export function calculateTotalMonthlyBills(
  bills: any[]
): { total: string; byCategory: Map<string, string> } {
  let total = BigInt(0);
  const byCategory = new Map<string, string>();

  for (const bill of bills) {
    const amount = BigInt(bill.metadata.averageAmount || '0');
    total += amount;

    const category = bill.metadata.billType || 'other';
    const currentCategoryTotal = BigInt(byCategory.get(category) || '0');
    byCategory.set(category, (currentCategoryTotal + amount).toString());
  }

  return { total: total.toString(), byCategory };
}
```

### Investment DCA Service & Helpers

```typescript name=backend/services/investmentDCAService.ts
import { ethers } from 'ethers';
import { DCAAutomation } from '../automations/DCAAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';
import {
  validateDCAConfig,
  calculateDCAMetrics,
  optimizeDCASchedule,
  analyzePriceMovement
} from '../helpers/investmentDCAHelpers.js';

export class InvestmentDCAService {
  private automation: DCAAutomation;
  private dbService: DatabaseService;

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    priceOracle: string,
    dbService: DatabaseService
  ) {
    this.automation = new DCAAutomation(wallyService, provider, priceOracle);
    this.dbService = dbService;
  }

  async createDCAStrategy(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate configuration
    const validation = validateDCAConfig(config.metadata);
    if (!validation.valid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // Initialize DCA tracking
    config.metadata.totalInvested = '0';
    config.metadata.averagePrice = '0';
    config.metadata.executionTimes = [];

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Start automation
    await this.automation.start(savedConfig);

    return savedConfig;
  }

  async getStrategyPerformance(
    strategyId: string
  ): Promise<{
    totalInvested: string;
    currentValue: string;
    profitLoss: string;
    profitLossPercentage: number;
    averageBuyPrice: string;
    currentPrice: string;
    executionCount: number;
  }> {
    const strategy = await this.dbService.getAutomation(strategyId);
    if (!strategy) throw new Error('Strategy not found');

    const metrics = await calculateDCAMetrics(strategy);
    return metrics;
  }

  async optimizeStrategy(
    strategyId: string
  ): Promise<{
    currentSchedule: string;
    suggestedSchedule: string;
    expectedImprovement: number;
    reasoning: string;
  }> {
    const strategy = await this.dbService.getAutomation(strategyId);
    if (!strategy) throw new Error('Strategy not found');

    const priceHistory = await this.fetchPriceHistory(
      strategy.metadata.targetToken,
      90 // 90 days
    );

    return optimizeDCASchedule(strategy, priceHistory);
  }

  async pauseStrategy(
    strategyId: string,
    reason?: string
  ): Promise<AutomationConfig> {
    const strategy = await this.dbService.getAutomation(strategyId);
    if (!strategy) throw new Error('Strategy not found');

    strategy.enabled = false;
    strategy.metadata.pausedAt = Date.now();
    strategy.metadata.pauseReason = reason;

    const updated = await this.dbService.updateAutomation(strategyId, strategy);
    this.automation.stop(strategyId);

    return updated!;
  }

  async getAllStrategiesValue(
    walletAddress: string
  ): Promise<{
    totalInvested: string;
    currentValue: string;
    strategies: Array<{
      id: string;
      name: string;
      invested: string;
      value: string;
      performance: number;
    }>;
  }> {
    const strategies = await this.dbService.getAutomations(walletAddress, 'DCA_INVESTMENT');
    let totalInvested = BigInt(0);
    let totalValue = BigInt(0);
    const strategyDetails = [];

    for (const strategy of strategies) {
      const metrics = await calculateDCAMetrics(strategy);
      totalInvested += BigInt(metrics.totalInvested);
      totalValue += BigInt(metrics.currentValue);

      strategyDetails.push({
        id: strategy.id,
        name: strategy.metadata.strategyName,
        invested: metrics.totalInvested,
        value: metrics.currentValue,
        performance: metrics.profitLossPercentage
      });
    }

    return {
      totalInvested: totalInvested.toString(),
      currentValue: totalValue.toString(),
      strategies: strategyDetails
    };
  }

  async getMarketAnalysis(
    tokenAddress: string
  ): Promise<{
    trend: 'bullish' | 'bearish' | 'neutral';
    volatility: 'low' | 'medium' | 'high';
    recommendation: string;
    signals: string[];
  }> {
    const priceHistory = await this.fetchPriceHistory(tokenAddress, 30);
    return analyzePriceMovement(priceHistory);
  }

  private async fetchPriceHistory(
    tokenAddress: string,
    days: number
  ): Promise<Array<{ timestamp: number; price: number }>> {
    // This would fetch from a price oracle or API
    // Simplified implementation
    const history = [];
    const now = Date.now();
    const basePrice = 2000; // Example base price

    for (let i = 0; i < days; i++) {
      history.push({
        timestamp: now - (i * 24 * 60 * 60 * 1000),
        price: basePrice + (Math.random() - 0.5) * 200 // Simulated volatility
      });
    }

    return history.reverse();
  }
}
```

```typescript name=backend/helpers/investmentDCAHelpers.ts
import { ethers } from 'ethers';
import { AutomationConfig } from '../../shared/types.js';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export function validateDCAConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.strategyName || metadata.strategyName.trim().length === 0) {
    errors.push('Strategy name is required');
  }

  if (!metadata.sourceToken || !ethers.isAddress(metadata.sourceToken)) {
    errors.push('Invalid source token address');
  }

  if (!metadata.targetToken || !ethers.isAddress(metadata.targetToken)) {
    errors.push('Invalid target token address');
  }

  const amount = parseFloat(metadata.amount || '0');
  if (amount <= 0) {
    errors.push('Amount must be greater than 0');
  }

  if (!['daily', 'weekly', 'biweekly', 'monthly'].includes(metadata.frequency)) {
    errors.push('Invalid frequency');
  }

  const slippage = metadata.slippageTolerance || 0;
  if (slippage < 10 || slippage > 1000) { // 0.1% to 10%
    errors.push('Slippage tolerance must be between 0.1% and 10%');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export async function calculateDCAMetrics(
  strategy: AutomationConfig
): Promise<{
  totalInvested: string;
  currentValue: string;
  profitLoss: string;
  profitLossPercentage: number;
  averageBuyPrice: string;
  currentPrice: string;
  executionCount: number;
}> {
  const totalInvested = BigInt(strategy.metadata.totalInvested || '0');
  const executionCount = strategy.metadata.executionTimes?.length || 0;
  
  // In real implementation, fetch current price from oracle
  const currentPrice = 2100; // Example current price
  const averageBuyPrice = parseFloat(strategy.metadata.averagePrice || '2000');
  
  // Calculate total tokens acquired
  const tokensAcquired = executionCount > 0 
    ? parseFloat(ethers.formatUnits(totalInvested, 18)) / averageBuyPrice
    : 0;
  
  const currentValue = tokensAcquired * currentPrice;
  const profitLoss = currentValue - parseFloat(ethers.formatUnits(totalInvested, 18));
  const profitLossPercentage = totalInvested > 0
    ? (profitLoss / parseFloat(ethers.formatUnits(totalInvested, 18))) * 100
    : 0;

  return {
    totalInvested: totalInvested.toString(),
    currentValue: ethers.parseUnits(currentValue.toString(), 18).toString(),
    profitLoss: ethers.parseUnits(profitLoss.toString(), 18).toString(),
    profitLossPercentage,
    averageBuyPrice: averageBuyPrice.toString(),
    currentPrice: currentPrice.toString(),
    executionCount
  };
}

export function optimizeDCASchedule(
  strategy: AutomationConfig,
  priceHistory: Array<{ timestamp: number; price: number }>
): {
  currentSchedule: string;
  suggestedSchedule: string;
  expectedImprovement: number;
  reasoning: string;
} {
  const currentFreq = strategy.metadata.frequency;
  const volatility = calculateVolatility(priceHistory);
  
  let suggestedSchedule = currentFreq;
  let reasoning = '';
  let expectedImprovement = 0;

  if (volatility > 0.3) {
    // High volatility - more frequent buys
    suggestedSchedule = 'daily';
    reasoning = 'High volatility detected. More frequent purchases can better average out price swings.';
    expectedImprovement = 15;
  } else if (volatility < 0.1) {
    // Low volatility - less frequent buys
    suggestedSchedule = 'monthly';
    reasoning = 'Low volatility detected. Less frequent purchases can reduce transaction costs.';
    expectedImprovement = 5;
  } else {
    // Medium volatility
    suggestedSchedule = 'weekly';
    reasoning = 'Moderate volatility. Weekly purchases provide good balance.';
    expectedImprovement = 10;
  }

  return {
    currentSchedule: currentFreq,
    suggestedSchedule,
    expectedImprovement,
    reasoning
  };
}

export function analyzePriceMovement(
  priceHistory: Array<{ timestamp: number; price: number }>
): {
  trend: 'bullish' | 'bearish' | 'neutral';
  volatility: 'low' | 'medium' | 'high';
  recommendation: string;
  signals: string[];
} {
  if (priceHistory.length < 2) {
    return {
      trend: 'neutral',
      volatility: 'medium',
      recommendation: 'Insufficient data for analysis',
      signals: []
    };
  }

  const signals: string[] = [];
  
  // Calculate trend
  const startPrice = priceHistory[0].price;
  const endPrice = priceHistory[priceHistory.length - 1].price;
  const priceChange = ((endPrice - startPrice) / startPrice) * 100;
  
  let trend: 'bullish' | 'bearish' | 'neutral';
  if (priceChange > 5) {
    trend = 'bullish';
    signals.push('Upward price trend detected');
  } else if (priceChange < -5) {
    trend = 'bearish';
    signals.push('Downward price trend detected');
  } else {
    trend = 'neutral';
    signals.push('Sideways price movement');
  }

  // Calculate volatility
  const volatilityValue = calculateVolatility(priceHistory);
  let volatility: 'low' | 'medium' | 'high';
  if (volatilityValue < 0.1) {
    volatility = 'low';
  } else if (volatilityValue < 0.3) {
    volatility = 'medium';
  } else {
    volatility = 'high';
    signals.push('High volatility - consider smaller position sizes');
  }

  // Generate recommendation
  let recommendation = '';
  if (trend === 'bearish' && volatility === 'high') {
    recommendation = 'Consider pausing DCA until market stabilizes';
  } else if (trend === 'bearish' && volatility === 'low') {
    recommendation = 'Good accumulation opportunity with stable downtrend';
  } else if (trend === 'bullish' && volatility === 'low') {
    recommendation = 'Steady uptrend - continue regular DCA';
  } else {
    recommendation = 'Market conditions favorable for DCA strategy';
  }

  return { trend, volatility, recommendation, signals };
}

function calculateVolatility(
  priceHistory: Array<{ timestamp: number; price: number }>
): number {
  if (priceHistory.length < 2) return 0;

  const returns = [];
  for (let i = 1; i < priceHistory.length; i++) {
    const dailyReturn = (priceHistory[i].price - priceHistory[i - 1].price) / priceHistory[i - 1].price;
    returns.push(dailyReturn);
  }

  const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;
  
  return Math.sqrt(variance);
}
```

### Emergency Fund Service & Helpers

```typescript name=backend/services/emergencyFundService.ts
import { EmergencyFundAutomation } from '../automations/EmergencyFundAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';
import {
  validateEmergencyFundConfig,
  calculateFundHealth,
  projectFundDepletion,
  suggestOptimalFundSize
} from '../helpers/emergencyFundHelpers.js';

export class EmergencyFundService {
  private automation: EmergencyFundAutomation;
  private dbService: DatabaseService;

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    dbService: DatabaseService
  ) {
    this.automation = new EmergencyFundAutomation(wallyService, provider);
    this.dbService = dbService;
  }

  async createEmergencyFund(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate configuration
    const validation = validateEmergencyFundConfig(config.metadata);
    if (!validation.valid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // Initialize fund tracking
    config.metadata.currentAmount = '0';
    config.metadata.history = [];
    config.metadata.lastChecked = Date.now();

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Start monitoring
    await this.automation.start(savedConfig);

    return savedConfig;
  }

  async getFundStatus(
    fundId: string
  ): Promise<{
    health: 'healthy' | 'warning' | 'critical';
    currentAmount: string;
    targetAmount: string;
    percentage: number;
    daysOfCoverage: number;
    recommendations: string[];
  }> {
    const fund = await this.dbService.getAutomation(fundId);
    if (!fund) throw new Error('Fund not found');

    const health = calculateFundHealth(fund);
    const depletion = projectFundDepletion(fund);

    return {
      ...health,
      daysOfCoverage: depletion.daysRemaining,
      recommendations: this.generateRecommendations(health, depletion)
    };
  }

  async withdrawFromFund(
    fundId: string,
    amount: string,
    reason: string,
    userAddress: string
  ): Promise<{ success: boolean; txHash?: string; newBalance?: string }> {
    try {
      await this.automation.emergencyWithdraw(fundId, amount, reason, userAddress);
      
      // Update fund balance
      const fund = await this.dbService.getAutomation(fundId);
      if (!fund) throw new Error('Fund not found');

      const currentAmount = BigInt(fund.metadata.currentAmount);
      const withdrawAmount = BigInt(amount);
      const newBalance = currentAmount - withdrawAmount;

      fund.metadata.currentAmount = newBalance.toString();
      fund.metadata.history.push({
        type: 'withdrawal',
        amount,
        timestamp: Date.now(),
        reason
      });

      await this.dbService.updateAutomation(fundId, fund);

      return {
        success: true,
        newBalance: newBalance.toString()
      };
    } catch (error) {
      return {
        success: false
      };
    }
  }

  async getWithdrawalHistory(
    fundId: string
  ): Promise<Array<{
    amount: string;
    reason: string;
    timestamp: Date;
  }>> {
    const fund = await this.dbService.getAutomation(fundId);
    if (!fund) throw new Error('Fund not found');

    return fund.metadata.history
      .filter((event: any) => event.type === 'withdrawal')
      .map((event: any) => ({
        amount: event.amount,
        reason: event.reason || 'No reason provided',
        timestamp: new Date(event.timestamp)
      }));
  }

  async calculateOptimalFundSize(
    walletAddress: string,
    monthlyExpenses?: string
  ): Promise<{
    suggestedTarget: string;
    suggestedMinimum: string;
    reasoning: string;
  }> {
    // Analyze user's spending patterns if monthly expenses not provided
    let estimatedMonthlyExpenses = monthlyExpenses;
    
    if (!estimatedMonthlyExpenses) {
      // In real implementation, analyze transaction history
      estimatedMonthlyExpenses = ethers.parseUnits('2000', 18).toString(); // Default $2000
    }

    return suggestOptimalFundSize(estimatedMonthlyExpenses);
  }

  async getAllFundsOverview(
    walletAddress: string
  ): Promise<{
    totalEmergencyFunds: string;
    fundsCount: number;
    healthStatus: 'healthy' | 'warning' | 'critical';
    coverage: {
      months: number;
      description: string;
    };
  }> {
    const funds = await this.dbService.getAutomations(walletAddress, 'EMERGENCY_FUND');
    
    let totalAmount = BigInt(0);
    let criticalCount = 0;
    let warningCount = 0;

    for (const fund of funds) {
      totalAmount += BigInt(fund.metadata.currentAmount || '0');
      const health = calculateFundHealth(fund);
      
      if (health.health === 'critical') criticalCount++;
      else if (health.health === 'warning') warningCount++;
    }

    // Determine overall health
    let overallHealth: 'healthy' | 'warning' | 'critical' = 'healthy';
    if (criticalCount > 0) overallHealth = 'critical';
    else if (warningCount > 0) overallHealth = 'warning';

    // Calculate coverage (simplified - assumes $2000/month expenses)
    const monthlyExpenses = ethers.parseUnits('2000', 18);
    const monthsCoverage = Number(totalAmount / monthlyExpenses);

    return {
      totalEmergencyFunds: totalAmount.toString(),
      fundsCount: funds.length,
      healthStatus: overallHealth,
      coverage: {
        months: monthsCoverage,
        description: this.getCoverageDescription(monthsCoverage)
      }
    };
  }

  private generateRecommendations(
    health: any,
    depletion: any
  ): string[] {
    const recommendations: string[] = [];

    if (health.health === 'critical') {
      recommendations.push('Urgent: Top up your emergency fund immediately');
    }

    if (depletion.daysRemaining < 30) {
      recommendations.push('Your fund will be depleted within a month at current usage');
    }

    if (health.percentage < 50) {
      recommendations.push('Consider increasing your regular contributions');
    }

    if (health.percentage > 150) {
      recommendations.push('You might have excess funds that could be invested');
    }

    return recommendations;
  }

  private getCoverageDescription(months: number): string {
    if (months < 1) return 'Less than 1 month - Critical';
    if (months < 3) return `${months.toFixed(1)} months - Below recommended`;
    if (months <= 6) return `${months.toFixed(1)} months - Good coverage`;
    if (months <= 12) return `${months.toFixed(1)} months - Excellent coverage`;
    return `${months.toFixed(1)} months - Consider investing excess`;
  }
}
```

```typescript name=backend/helpers/emergencyFundHelpers.ts
import { ethers } from 'ethers';
import { AutomationConfig } from '../../shared/types.js';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export function validateEmergencyFundConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.fundName || metadata.fundName.trim().length === 0) {
    errors.push('Fund name is required');
  }

  const targetAmount = parseFloat(metadata.targetAmount || '0');
  if (targetAmount <= 0) {
    errors.push('Target amount must be greater than 0');
  }

  const minThreshold = parseFloat(metadata.minThreshold || '0');
  if (minThreshold <= 0) {
    errors.push('Minimum threshold must be greater than 0');
  }

  if (minThreshold >= targetAmount) {
    errors.push('Minimum threshold must be less than target amount');
  }

  if (!metadata.fundAddress || !ethers.isAddress(metadata.fundAddress)) {
    errors.push('Invalid fund storage address');
  }

  const checkInterval = parseInt(metadata.checkInterval || '0');
  if (checkInterval < 3600) { // Minimum 1 hour
    errors.push('Check interval must be at least 1 hour');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export function calculateFundHealth(
  fund: AutomationConfig
): {
  health: 'healthy' | 'warning' | 'critical';
  currentAmount: string;
  targetAmount: string;
  percentage: number;
} {
  const current = BigInt(fund.metadata.currentAmount || '0');
  const target = BigInt(fund.metadata.targetAmount);
  const minimum = BigInt(fund.metadata.minThreshold);

  const percentage = Number((current * BigInt(100)) / target);
  
  let health: 'healthy' | 'warning' | 'critical';
  if (current < minimum) {
    health = 'critical';
  } else if (current < (minimum * BigInt(120)) / BigInt(100)) { // Less than 120% of minimum
    health = 'warning';
  } else {
    health = 'healthy';
  }

  return {
    health,
    currentAmount: current.toString(),
    targetAmount: target.toString(),
    percentage
  };
}

export function projectFundDepletion(
  fund: AutomationConfig
): {
  daysRemaining: number;
  projectedDepletionDate: Date | null;
  averageDailyUsage: string;
} {
  const history = fund.metadata.history || [];
  const withdrawals = history.filter((h: any) => h.type === 'withdrawal');

  if (withdrawals.length === 0) {
    return {
      daysRemaining: Infinity,
      projectedDepletionDate: null,
      averageDailyUsage: '0'
    };
  }

  // Calculate average daily usage over last 30 days
  const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
  const recentWithdrawals = withdrawals.filter((w: any) => w.timestamp > thirtyDaysAgo);

  if (recentWithdrawals.length === 0) {
    return {
      daysRemaining: Infinity,
      projectedDepletionDate: null,
      averageDailyUsage: '0'
    };
  }

  let totalWithdrawn = BigInt(0);
  for (const withdrawal of recentWithdrawals) {
    totalWithdrawn += BigInt(withdrawal.amount);
  }

  const daysPeriod = 30;
  const avgDailyUsage = totalWithdrawn / BigInt(daysPeriod);
  const currentAmount = BigInt(fund.metadata.currentAmount || '0');

  if (avgDailyUsage === BigInt(0)) {
    return {
      daysRemaining: Infinity,
      projectedDepletionDate: null,
      averageDailyUsage: '0'
    };
  }

  const daysRemaining = Number(currentAmount / avgDailyUsage);
  const depletionDate = new Date(Date.now() + (daysRemaining * 24 * 60 * 60 * 1000));

  return {
    daysRemaining,
    projectedDepletionDate: depletionDate,
    averageDailyUsage: avgDailyUsage.toString()
  };
}

export function suggestOptimalFundSize(
  monthlyExpenses: string
): {
  suggestedTarget: string;
  suggestedMinimum: string;
  reasoning: string;
} {
  const monthly = BigInt(monthlyExpenses);
  
  // Standard recommendation: 3-6 months of expenses
  const suggestedMinimum = monthly * BigInt(3);
  const suggestedTarget = monthly * BigInt(6);

  const reasoning = `Based on monthly expenses of ${ethers.formatUnits(monthly, 18)}, ` +
    `we recommend maintaining 3-6 months of expenses. ` +
    `3 months (${ethers.formatUnits(suggestedMinimum, 18)}) provides basic security, ` +
    `while 6 months (${ethers.formatUnits(suggestedTarget, 18)}) offers comprehensive protection.`;

  return {
    suggestedTarget: suggestedTarget.toString(),
    suggestedMinimum: suggestedMinimum.toString(),
    reasoning
  };
}

export function analyzeWithdrawalPatterns(
  history: Array<{ type: string; amount: string; timestamp: number; reason?: string }>
): {
  commonReasons: Map<string, number>;
  averageWithdrawal: string;
  frequency: 'rare' | 'occasional' | 'frequent';
  largestWithdrawal: { amount: string; reason: string; date: Date };
} {
  const withdrawals = history.filter(h => h.type === 'withdrawal');
  
  if (withdrawals.length === 0) {
    return {
      commonReasons: new Map(),
      averageWithdrawal: '0',
      frequency: 'rare',
      largestWithdrawal: { amount: '0', reason: 'None', date: new Date() }
    };
  }

  // Analyze reasons
  const commonReasons = new Map<string, number>();
  let totalAmount = BigInt(0);
  let largestAmount = BigInt(0);
  let largestWithdrawal = withdrawals[0];

  for (const withdrawal of withdrawals) {
    const reason = withdrawal.reason || 'Unspecified';
    commonReasons.set(reason, (commonReasons.get(reason) || 0) + 1);
    
    const amount = BigInt(withdrawal.amount);
    totalAmount += amount;
    
    if (amount > largestAmount) {
      largestAmount = amount;
      largestWithdrawal = withdrawal;
    }
  }

  const averageWithdrawal = totalAmount / BigInt(withdrawals.length);

  // Determine frequency
  const daysSinceFirst = (Date.now() - withdrawals[0].timestamp) / (1000 * 60 * 60 * 24);
  const withdrawalsPerMonth = (withdrawals.length / daysSinceFirst) * 30;
  
  let frequency: 'rare' | 'occasional' | 'frequent';
  if (withdrawalsPerMonth < 0.5) frequency = 'rare';
  else if (withdrawalsPerMonth < 2) frequency = 'occasional';
  else frequency = 'frequent';

  return {
    commonReasons,
    averageWithdrawal: averageWithdrawal.toString(),
    frequency,
    largestWithdrawal: {
      amount: largestWithdrawal.amount,
      reason: largestWithdrawal.reason || 'Unspecified',
      date: new Date(largestWithdrawal.timestamp)
    }
  };
}
```

### Charity Donation Service & Helpers

You're right! Let me complete the charityDonationService.ts and then provide all the remaining files.

### Completing Charity Donation Service

```typescript name=backend/services/charityDonationService.ts
import { ethers } from 'ethers';
import { CharityDonationAutomation } from '../automations/CharityDonationAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';
import {
  validateCharityConfig,
  calculateTaxBenefit,
  generateDonationReceipt,
  analyzeCharityImpact
} from '../helpers/charityDonationHelpers.js';

export class CharityDonationService {
  private automation: CharityDonationAutomation;
  private dbService: DatabaseService;

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    dbService: DatabaseService
  ) {
    this.automation = new CharityDonationAutomation(wallyService, provider);
    this.dbService = dbService;
  }

  async setupDonation(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate configuration
    const validation = validateCharityConfig(config.metadata);
    if (!validation.valid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // Initialize donation tracking
    config.metadata.totalDonated = '0';
    config.metadata.donationHistory = [];

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Start automation
    await this.automation.start(savedConfig);

    return savedConfig;
  }

  async makeOneTimeDonation(
    charityId: string,
    amount: string,
    userAddress: string
  ): Promise<{
    success: boolean;
    txHash?: string;
    receiptId?: string;
  }> {
    try {
      await this.automation.makeOneTimeDonation(charityId, amount, userAddress);
      
      // Generate receipt if tax deductible
      const charity = await this.dbService.getAutomation(charityId);
      let receiptId: string | undefined;
      
      if (charity?.metadata.taxDeductible) {
        receiptId = await generateDonationReceipt({
          charityName: charity.metadata.charityName,
          taxId: charity.metadata.taxId,
          amount,
          donorAddress: userAddress,
          timestamp: Date.now()
        });
      }

      return { success: true, receiptId };
    } catch (error) {
      return { success: false };
    }
  }

  async getTaxSummary(
    userAddress: string,
    year: number
  ): Promise<{
    totalDonated: string;
    estimatedTaxBenefit: string;
    charities: Array<{
      name: string;
      taxId: string;
      totalDonated: string;
      receipts: string[];
    }>;
  }> {
    const summary = await this.automation.getAnnualTaxSummary(userAddress, year);
    
    // Calculate tax benefit
    const taxBenefit = calculateTaxBenefit(
      summary.totalDonated,
      'standard' // Would determine actual tax bracket
    );

    return {
      ...summary,
      estimatedTaxBenefit: taxBenefit
    };
  }

  async getCharityStats(
    charityAddress: string
  ): Promise<{
    totalReceived: string;
    donorCount: number;
    averageDonation: string;
    impactScore: number;
  }> {
    // Aggregate donations to this charity across all users
    const donations = await this.dbService.getAutomations(undefined, 'CHARITY_DONATION');
    
    let totalReceived = BigInt(0);
    const donors = new Set<string>();
    let donationCount = 0;

    for (const donation of donations) {
      if (donation.metadata.charityAddress === charityAddress) {
        totalReceived += BigInt(donation.metadata.totalDonated || '0');
        donors.add(donation.walletAddress);
        donationCount += donation.metadata.donationHistory?.length || 0;
      }
    }

    const averageDonation = donationCount > 0 
      ? totalReceived / BigInt(donationCount)
      : BigInt(0);

    const impactScore = await analyzeCharityImpact(charityAddress);

    return {
      totalReceived: totalReceived.toString(),
      donorCount: donors.size,
      averageDonation: averageDonation.toString(),
      impactScore
    };
  }

  async getRoundUpStats(
    userAddress: string
  ): Promise<{
    totalRoundUpDonated: string;
    roundUpCount: number;
    averageRoundUp: string;
    currentMonthTotal: string;
  }> {
    const configs = await this.dbService.getAutomations(userAddress, 'CHARITY_DONATION');
    
    let totalRoundUp = BigInt(0);
    let roundUpCount = 0;
    let currentMonthTotal = BigInt(0);
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();

    for (const config of configs) {
      const history = config.metadata.donationHistory || [];
      
      for (const donation of history) {
        if (donation.roundUpAmount) {
          totalRoundUp += BigInt(donation.roundUpAmount);
          roundUpCount++;
          
          const donationDate = new Date(donation.timestamp);
          if (donationDate.getMonth() === currentMonth && 
              donationDate.getFullYear() === currentYear) {
            currentMonthTotal += BigInt(donation.roundUpAmount);
          }
        }
      }
    }

    const averageRoundUp = roundUpCount > 0 
      ? totalRoundUp / BigInt(roundUpCount)
      : BigInt(0);

    return {
      totalRoundUpDonated: totalRoundUp.toString(),
      roundUpCount,
      averageRoundUp: averageRoundUp.toString(),
      currentMonthTotal: currentMonthTotal.toString()
    };
  }

  async toggleRoundUp(
    configId: string,
    enabled: boolean
  ): Promise<AutomationConfig> {
    const config = await this.dbService.getAutomation(configId);
    if (!config) throw new Error('Configuration not found');

    config.metadata.roundUpEnabled = enabled;
    
    const updated = await this.dbService.updateAutomation(configId, config);
    
    // Restart automation to apply changes
    this.automation.stop(configId);
    await this.automation.start(updated!);

    return updated!;
  }

  async getRecommendedCharities(
    category?: string
  ): Promise<Array<{
    name: string;
    address: string;
    taxId: string;
    category: string;
    description: string;
    impactScore: number;
    verified: boolean;
  }>> {
    // In production, this would fetch from a curated database
    const charities = [
      {
        name: 'GiveDirectly',
        address: '0x750EF1D7a54b69e66F2aF3c3F1f4e31c0A3B3E47',
        taxId: '27-1661997',
        category: 'poverty',
        description: 'Direct cash transfers to people living in poverty',
        impactScore: 95,
        verified: true
      },
      {
        name: 'The Water Project',
        address: '0x3E5e9111Ae7feBef6E5c1E0e8C7395B1B0B7bB47',
        taxId: '37-1424750',
        category: 'water',
        description: 'Clean water solutions for communities in Africa',
        impactScore: 92,
        verified: true
      },
      {
        name: 'Electronic Frontier Foundation',
        address: '0x095f1fD53A66CF59C3C3D3A9c0f9a7Eb2A7bB47',
        taxId: '04-3091431',
        category: 'technology',
        description: 'Defending civil liberties in the digital world',
        impactScore: 88,
        verified: true
      }
    ];

    if (category) {
      return charities.filter(c => c.category === category);
    }

    return charities;
  }
}
```

### Charity Donation Helpers

```typescript name=backend/helpers/charityDonationHelpers.ts
import { ethers } from 'ethers';
import crypto from 'crypto';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

interface DonationReceiptData {
  charityName: string;
  taxId: string;
  amount: string;
  donorAddress: string;
  timestamp: number;
}

export function validateCharityConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.charityName || metadata.charityName.trim().length === 0) {
    errors.push('Charity name is required');
  }

  if (!metadata.charityAddress || !ethers.isAddress(metadata.charityAddress)) {
    errors.push('Invalid charity address');
  }

  if (!metadata.category) {
    errors.push('Charity category is required');
  }

  if (metadata.donationType === 'recurring') {
    const amount = parseFloat(metadata.amount || '0');
    if (amount <= 0) {
      errors.push('Recurring donation amount must be greater than 0');
    }

    if (!['monthly', 'quarterly', 'yearly'].includes(metadata.frequency)) {
      errors.push('Invalid donation frequency');
    }
  }

  if (metadata.roundUpEnabled) {
    const maxRoundUp = parseFloat(metadata.roundUpMax || '0');
    if (maxRoundUp <= 0 || maxRoundUp > 100) {
      errors.push('Round-up maximum must be between 0 and 100');
    }
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export function calculateTaxBenefit(
  totalDonated: string,
  taxBracket: 'low' | 'standard' | 'high'
): string {
  const donated = BigInt(totalDonated);
  
  // Simplified US tax brackets
  const taxRates = {
    low: 12,      // 12%
    standard: 22, // 22%
    high: 35      // 35%
  };

  const rate = taxRates[taxBracket];
  const benefit = (donated * BigInt(rate)) / BigInt(100);

  return benefit.toString();
}

export async function generateDonationReceipt(
  data: DonationReceiptData
): Promise<string> {
  // Generate unique receipt ID
  const receiptId = `DON-${data.taxId}-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
  
  // In production, this would:
  // 1. Generate a PDF receipt
  // 2. Store it in IPFS or cloud storage
  // 3. Send email to donor
  // 4. Return the receipt ID/URL

  // For now, we'll simulate storing the receipt
  const receipt = {
    id: receiptId,
    ...data,
    formattedAmount: ethers.formatUnits(data.amount, 18),
    date: new Date(data.timestamp).toISOString(),
    taxYear: new Date(data.timestamp).getFullYear()
  };

  // Simulate async storage
  await new Promise(resolve => setTimeout(resolve, 100));
  
  console.log('Generated donation receipt:', receipt);
  
  return receiptId;
}

export async function analyzeCharityImpact(
  charityAddress: string
): Promise<number> {
  // In production, this would analyze:
  // 1. Charity's financial transparency
  // 2. Program efficiency ratio
  // 3. Administrative cost ratio
  // 4. Impact reports
  // 5. Third-party ratings (CharityNavigator, GiveWell, etc.)

  // Simplified scoring based on address (mock data)
  const knownCharities = {
    '0x750EF1D7a54b69e66F2aF3c3F1f4e31c0A3B3E47': 95, // GiveDirectly
    '0x3E5e9111Ae7feBef6E5c1E0e8C7395B1B0B7bB47': 92, // The Water Project
    '0x095f1fD53A66CF59C3C3D3A9c0f9a7Eb2A7bB47': 88  // EFF
  };

  return knownCharities[charityAddress] || 70; // Default score
}

export function calculateRoundUpAmount(
  transactionAmount: bigint,
  maxRoundUp: bigint
): bigint {
  // Round up to the nearest dollar/unit
  const unit = ethers.parseUnits('1', 18);
  const remainder = transactionAmount % unit;
  
  if (remainder === BigInt(0)) {
    return BigInt(0); // Already a whole number
  }
  
  const roundUpAmount = unit - remainder;
  
  // Cap at maximum round-up amount
  return roundUpAmount > maxRoundUp ? maxRoundUp : roundUpAmount;
}

export function categorizeCharities(
  charities: any[]
): Map<string, { charities: any[]; totalDonated: string }> {
  const categorized = new Map<string, { charities: any[]; totalDonated: string }>();
  
  for (const charity of charities) {
    const category = charity.metadata.category || 'other';
    
    if (!categorized.has(category)) {
      categorized.set(category, { charities: [], totalDonated: '0' });
    }
    
    const categoryData = categorized.get(category)!;
    categoryData.charities.push(charity);
    categoryData.totalDonated = (
      BigInt(categoryData.totalDonated) + 
      BigInt(charity.metadata.totalDonated || '0')
    ).toString();
  }

  return categorized;
}

export function generateTaxReport(
  donations: Array<{
    charityName: string;
    taxId: string;
    amount: string;
    date: Date;
    receiptId: string;
  }>,
  year: number
): {
  totalDeductible: string;
  charityBreakdown: Map<string, { total: string; donations: number }>;
  monthlyBreakdown: Map<number, string>;
} {
  let totalDeductible = BigInt(0);
  const charityBreakdown = new Map<string, { total: string; donations: number }>();
  const monthlyBreakdown = new Map<number, string>();

  for (const donation of donations) {
    if (donation.date.getFullYear() !== year) continue;

    const amount = BigInt(donation.amount);
    totalDeductible += amount;

    // By charity
    const charityKey = `${donation.charityName} (${donation.taxId})`;
    if (!charityBreakdown.has(charityKey)) {
      charityBreakdown.set(charityKey, { total: '0', donations: 0 });
    }
    const charityData = charityBreakdown.get(charityKey)!;
    charityData.total = (BigInt(charityData.total) + amount).toString();
    charityData.donations++;

    // By month
    const month = donation.date.getMonth();
    const currentMonthTotal = BigInt(monthlyBreakdown.get(month) || '0');
    monthlyBreakdown.set(month, (currentMonthTotal + amount).toString());
  }

  return {
    totalDeductible: totalDeductible.toString(),
    charityBreakdown,
    monthlyBreakdown
  };
}
```

### Multi-Wallet Consolidation Service

```typescript name=backend/services/multiWalletConsolidationService.ts
import { ethers } from 'ethers';
import { MultiWalletConsolidationAutomation } from '../automations/MultiWalletConsolidationAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';
import {
  validateConsolidationConfig,
  analyzeWalletActivity,
  optimizeConsolidationOrder,
  estimateConsolidationCost
} from '../helpers/multiWalletConsolidationHelpers.js';

export class MultiWalletConsolidationService {
  private automation: MultiWalletConsolidationAutomation;
  private dbService: DatabaseService;

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    priceOracle: string,
    dbService: DatabaseService
  ) {
    this.automation = new MultiWalletConsolidationAutomation(wallyService, provider, priceOracle);
    this.dbService = dbService;
  }

  async createConsolidation(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate configuration
    const validation = validateConsolidationConfig(config.metadata);
    if (!validation.valid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // Initialize consolidation tracking
    config.metadata.totalConsolidated = '0';
    config.metadata.consolidationHistory = [];
    config.metadata.lastRun = 0;

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Start automation
    await this.automation.start(savedConfig);

    return savedConfig;
  }

  async addWallet(
    consolidationId: string,
    wallet: {
      address: string;
      nickname: string;
      minBalance: string;
      priority: number;
    }
  ): Promise<AutomationConfig> {
    const config = await this.dbService.getAutomation(consolidationId);
    if (!config) throw new Error('Consolidation not found');

    await this.automation.addSourceWallet(consolidationId, {
      ...wallet,
      enabled: true,
      lastChecked: Date.now()
    });

    return await this.dbService.getAutomation(consolidationId) || config;
  }

  async removeWallet(
    consolidationId: string,
    walletAddress: string
  ): Promise<AutomationConfig> {
    await this.automation.removeSourceWallet(consolidationId, walletAddress);
    return await this.dbService.getAutomation(consolidationId)!;
  }

  async analyzeConsolidationOpportunity(
    consolidationId: string
  ): Promise<{
    potentialSavings: string;
    recommendedWallets: string[];
    estimatedGasCost: string;
    optimalTime: Date;
  }> {
    const config = await this.dbService.getAutomation(consolidationId);
    if (!config) throw new Error('Consolidation not found');

    // Analyze each wallet
    const opportunities = [];
    
    for (const wallet of config.metadata.sourceWallets) {
      if (!wallet.enabled) continue;

      const activity = await analyzeWalletActivity(wallet.address);
      
      if (activity.hasConsolidationOpportunity) {
        opportunities.push({
          wallet: wallet.address,
          value: activity.consolidatableValue,
          gasEstimate: activity.estimatedGas
        });
      }
    }

    const totalValue = opportunities.reduce(
      (sum, o) => sum + BigInt(o.value),
      BigInt(0)
    );

    const totalGas = opportunities.reduce(
      (sum, o) => sum + BigInt(o.gasEstimate),
      BigInt(0)
    );

    return {
      potentialSavings: totalValue.toString(),
      recommendedWallets: opportunities.map(o => o.wallet),
      estimatedGasCost: totalGas.toString(),
      optimalTime: this.calculateOptimalConsolidationTime()
    };
  }

  async getConsolidationHistory(
    consolidationId: string,
    limit: number = 50
  ): Promise<Array<{
    timestamp: Date;
    sourceWallet: string;
    transfers: number;
    totalValue: string;
    gasCost: string;
  }>> {
    const config = await this.dbService.getAutomation(consolidationId);
    if (!config) throw new Error('Consolidation not found');

    const history = config.metadata.consolidationHistory || [];
    
    return history
      .slice(-limit)
      .map(event => ({
        timestamp: new Date(event.timestamp),
        sourceWallet: event.sourceWallet,
        transfers: event.transfers.length,
        totalValue: event.totalValue,
        gasCost: event.transfers.reduce(
          (sum, t) => sum + BigInt(t.gasUsed),
          BigInt(0)
        ).toString()
      }))
      .reverse();
  }

  async optimizeConfiguration(
    consolidationId: string
  ): Promise<{
    currentConfig: any;
    optimizedConfig: any;
    expectedImprovement: string;
  }> {
    const config = await this.dbService.getAutomation(consolidationId);
    if (!config) throw new Error('Consolidation not found');

    // Analyze wallet priorities and thresholds
    const optimized = await optimizeConsolidationOrder(config);

    return {
      currentConfig: {
        frequency: config.metadata.frequency,
        threshold: config.metadata.consolidationThreshold,
        gasStrategy: config.metadata.gasOptimization
      },
      optimizedConfig: optimized.config,
      expectedImprovement: optimized.expectedSavings
    };
  }

  async estimateNextConsolidation(
    consolidationId: string
  ): Promise<{
    estimatedDate: Date;
    expectedTransfers: number;
    expectedValue: string;
    expectedGasCost: string;
  }> {
    const config = await this.dbService.getAutomation(consolidationId);
    if (!config) throw new Error('Consolidation not found');

    const estimation = await estimateConsolidationCost(config);

    return {
      estimatedDate: this.calculateNextRunDate(config),
      expectedTransfers: estimation.transferCount,
      expectedValue: estimation.totalValue,
      expectedGasCost: estimation.totalGas
    };
  }

  private calculateOptimalConsolidationTime(): Date {
    // Analyze gas prices and network congestion
    // For now, return next Sunday at 2 AM (typically low gas)
    const now = new Date();
    const daysUntilSunday = (7 - now.getDay()) % 7 || 7;
    const optimalTime = new Date(now);
    optimalTime.setDate(now.getDate() + daysUntilSunday);
    optimalTime.setHours(2, 0, 0, 0);
    
    return optimalTime;
  }

  private calculateNextRunDate(config: AutomationConfig): Date {
    const lastRun = new Date(config.metadata.lastRun || Date.now());
    const nextRun = new Date(lastRun);

    switch (config.metadata.frequency) {
      case 'hourly':
        nextRun.setHours(nextRun.getHours() + 1);
        break;
      case 'daily':
        nextRun.setDate(nextRun.getDate() + 1);
        break;
      case 'weekly':
        nextRun.setDate(nextRun.getDate() + 7);
        break;
      default:
        // Manual only
        return new Date();
    }

    return nextRun;
  }
}
```

### Multi-Wallet Consolidation Helpers

```typescript name=backend/helpers/multiWalletConsolidationHelpers.ts
import { ethers } from 'ethers';
import { AutomationConfig } from '../../shared/types.js';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

interface WalletActivity {
  hasConsolidationOpportunity: boolean;
  consolidatableValue: string;
  estimatedGas: string;
  lastActivity: Date;
  risk: 'low' | 'medium' | 'high';
}

export function validateConsolidationConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.consolidationName || metadata.consolidationName.trim().length === 0) {
    errors.push('Consolidation name is required');
  }

  if (!metadata.primaryWallet || !ethers.isAddress(metadata.primaryWallet)) {
    errors.push('Invalid primary wallet address');
  }

  if (!['hourly', 'daily', 'weekly', 'manual'].includes(metadata.frequency)) {
    errors.push('Invalid consolidation frequency');
  }

  const threshold = parseFloat(metadata.consolidationThreshold || '0');
  if (threshold <= 0) {
    errors.push('Consolidation threshold must be greater than 0');
  }

  if (!Array.isArray(metadata.tokens) || metadata.tokens.length === 0) {
    errors.push('At least one token must be specified');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export async function analyzeWalletActivity(
  walletAddress: string,
  provider?: ethers.Provider
): Promise<WalletActivity> {
  // In production, this would analyze:
  // 1. Recent transaction history
  // 2. Token balances
  // 3. Gas costs for transfers
  // 4. Security risks

  // Simplified mock implementation
  const hasOpportunity = Math.random() > 0.3; // 70% chance of opportunity
  const value = hasOpportunity 
    ? ethers.parseUnits((Math.random() * 100).toFixed(2), 18).toString()
    : '0';

  return {
    hasConsolidationOpportunity: hasOpportunity,
    consolidatableValue: value,
    estimatedGas: '65000', // Standard ERC20 transfer
    lastActivity: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000),
    risk: 'low'
  };
}

export async function optimizeConsolidationOrder(
  config: AutomationConfig
): Promise<{
  config: any;
  expectedSavings: string;
}> {
  const wallets = config.metadata.sourceWallets || [];
  
  // Sort by priority and expected value
  const optimizedOrder = wallets.sort((a, b) => {
    // Higher priority first
    if (a.priority !== b.priority) {
      return b.priority - a.priority;
    }
    
    // Then by last checked (oldest first)
    return a.lastChecked - b.lastChecked;
  });

  // Suggest optimal threshold based on gas prices
  const currentThreshold = parseFloat(config.metadata.consolidationThreshold);
  const suggestedThreshold = calculateOptimalThreshold();

  // Calculate expected savings
  const savingsPercent = 15; // Estimated 15% savings with optimization
  const expectedSavings = ((currentThreshold * savingsPercent) / 100).toFixed(2);

  return {
    config: {
      walletOrder: optimizedOrder.map(w => w.address),
      frequency: suggestOptimalFrequency(wallets.length),
      threshold: suggestedThreshold,
      gasStrategy: true,
      batchSize: calculateOptimalBatchSize(wallets.length)
    },
    expectedSavings: `${expectedSavings} USD per consolidation`
  };
}

export async function estimateConsolidationCost(
  config: AutomationConfig
): Promise<{
  transferCount: number;
  totalValue: string;
  totalGas: string;
  breakdown: Array<{
    wallet: string;
    transfers: number;
    value: string;
    gas: string;
  }>;
}> {
  const breakdown = [];
  let totalTransfers = 0;
  let totalValue = BigInt(0);
  let totalGas = BigInt(0);

  for (const wallet of config.metadata.sourceWallets) {
    if (!wallet.enabled) continue;

    // Estimate transfers for this wallet
    const transfers = Math.floor(Math.random() * 5) + 1; // 1-5 transfers
    const value = ethers.parseUnits((Math.random() * 50).toFixed(2), 18);
    const gas = BigInt(65000) * BigInt(transfers);

    breakdown.push({
      wallet: wallet.address,
      transfers,
      value: value.toString(),
      gas: gas.toString()
    });

    totalTransfers += transfers;
    totalValue += value;
    totalGas += gas;
  }

  return {
    transferCount: totalTransfers,
    totalValue: totalValue.toString(),
    totalGas: totalGas.toString(),
    breakdown
  };
}

function calculateOptimalThreshold(): number {
  // In production, this would consider:
  // 1. Current gas prices
  // 2. Historical gas price patterns
  // 3. Token values
  
  // For now, return a reasonable default
  return 25; // $25 threshold
}

function suggestOptimalFrequency(walletCount: number): string {
  if (walletCount <= 3) return 'weekly';
  if (walletCount <= 10) return 'daily';
  return 'hourly'; // Many wallets need frequent checks
}

function calculateOptimalBatchSize(walletCount: number): number {
  // Balance between gas efficiency and transaction size
  if (walletCount <= 5) return walletCount;
  if (walletCount <= 20) return 10;
  return 20; // Max batch size
}

export function calculateConsolidationMetrics(
  history: any[]
): {
  totalConsolidated: string;
  averagePerConsolidation: string;
  totalGasSpent: string;
  efficiency: number; // Value consolidated per gas unit
  mostActiveWallet: string;
  consolidationsByMonth: Map<string, number>;
} {
  let totalValue = BigInt(0);
  let totalGas = BigInt(0);
  const walletCounts = new Map<string, number>();
  const monthlyConsolidations = new Map<string, number>();

  for (const event of history) {
    totalValue += BigInt(event.totalValue || '0');
    
    // Count by wallet
    walletCounts.set(
      event.sourceWallet,
      (walletCounts.get(event.sourceWallet) || 0) + 1
    );

    // Count by month
    const date = new Date(event.timestamp);
    const monthKey = `${date.getFullYear()}-${date.getMonth() + 1}`;
    monthlyConsolidations.set(
      monthKey,
      (monthlyConsolidations.get(monthKey) || 0) + 1
    );

    // Sum gas costs
    for (const transfer of event.transfers) {
      totalGas += BigInt(transfer.gasUsed || '0');
    }
  }

  const avgPerConsolidation = history.length > 0
    ? totalValue / BigInt(history.length)
    : BigInt(0);

  const efficiency = totalGas > 0
    ? Number((totalValue * BigInt(1000)) / totalGas) / 1000
    : 0;

  // Find most active wallet
  let mostActiveWallet = '';
  let maxCount = 0;
  for (const [wallet, count] of walletCounts) {
    if (count > maxCount) {
      maxCount = count;
      mostActiveWallet = wallet;
    }
  }

  return {
    totalConsolidated: totalValue.toString(),
    averagePerConsolidation: avgPerConsolidation.toString(),
    totalGasSpent: totalGas.toString(),
    efficiency,
    mostActiveWallet,
    consolidationsByMonth: monthlyConsolidations
  };
}
```

### Zero Out Old Wallet Service

```typescript name=backend/services/zeroOutOldWalletService.ts
import { ethers } from 'ethers';
import { ZeroOutWalletAutomation } from '../automations/ZeroOutWalletAutomation.js';
import { DatabaseService } from './DatabaseService.js';
import { WallyService } from './WallyService.js';
import { AutomationConfig } from '../../shared/types.js';

export class ZeroOutOldWalletService {
  private automation: ZeroOutWalletAutomation;
  private dbService: DatabaseService;

  constructor(
    wallyService: WallyService,
    provider: ethers.Provider,
    tokenListProvider: string,
    priceOracle: string,
    dbService: DatabaseService
  ) {
    this.automation = new ZeroOutWalletAutomation(wallyService, provider, tokenListProvider, priceOracle);
    this.dbService = dbService;
  }

  async initiateZeroOut(config: Partial<AutomationConfig>): Promise<AutomationConfig> {
    // Validate source and target wallets
    if (!ethers.isAddress(config.metadata.sourceWallet)) {
      throw new Error('Invalid source wallet address');
    }
    if (!ethers.isAddress(config.metadata.targetWallet)) {
      throw new Error('Invalid target wallet address');
    }

    // Initialize zero-out tracking
    config.metadata.status = 'scanning';
    config.metadata.discoveredAssets = [];
    config.metadata.executionPlan = [];
    config.metadata.estimatedValue = '0';

    // Create in database
    const savedConfig = await this.dbService.createAutomation(config);

    // Start the zero-out process
    await this.automation.start(savedConfig);

    return savedConfig;
  }

  async getZeroOutStatus(
    zeroOutId: string
  ): Promise<{
    status: string;
    progress: number;
    discoveredAssets: number;
    transferredAssets: number;
    totalValue: string;
    errors: string[];
  }> {
    const config = await this.dbService.getAutomation(zeroOutId);
    if (!config) throw new Error('Zero-out configuration not found');

    const assets = config.metadata.discoveredAssets || [];
    const plan = config.metadata.executionPlan || [];
    
    const completedTransfers = plan.filter((p: any) => p.status === 'completed').length;
    const progress = plan.length > 0 ? (completedTransfers / plan.length) * 100 : 0;

    const errors = plan
      .filter((p: any) => p.status === 'failed')
      .map((p: any) => p.error || 'Unknown error');

    return {
      status: config.metadata.status,
      progress,
      discoveredAssets: assets.length,
      transferredAssets: completedTransfers,
      totalValue: config.metadata.estimatedValue,
      errors
    };
  }

  async retryFailedTransfers(zeroOutId: string): Promise<void> {
    const config = await this.dbService.getAutomation(zeroOutId);
    if (!config) throw new Error('Zero-out configuration not found');

    // Reset failed transfers to pending
    const plan = config.metadata.executionPlan || [];
    for (const item of plan) {
      if (item.status === 'failed') {
        item.status = 'pending';
        delete item.error;
      }
    }

    config.metadata.status = 'executing';
    await this.dbService.updateAutomation(zeroOutId, config);

    // Restart execution
    await this.automation.start(config);
  }

  async cancelZeroOut(zeroOutId: string): Promise<void> {
    this.automation.stop(zeroOutId);
    
    const config = await this.dbService.getAutomation(zeroOutId);
    if (config) {
      config.metadata.status = 'cancelled';
      await this.dbService.updateAutomation(zeroOutId, config);
    }
  }

  async estimateZeroOutCost(
    sourceWallet: string,
    options: {
      includeNFTs: boolean;
      includeTokens: boolean;
      includeNative: boolean;
      scanDepth: 'basic' | 'deep';
    }
  ): Promise<{
    estimatedAssets: number;
    estimatedValue: string;
    estimatedGasCost: string;
    estimatedTime: number; // minutes
  }> {
    // Quick estimation based on wallet analysis
    // In production, this would do a preliminary scan
    
    const baseAssets = 5; // Assume 5 assets minimum
    let totalAssets = baseAssets;
    
    if (options.includeTokens) totalAssets += 10;
    if (options.includeNFTs) totalAssets += 5;
    
    const avgGasPerTransfer = BigInt(65000);
    const totalGas = avgGasPerTransfer * BigInt(totalAssets);
    
    // Assume $100 average value per asset (very rough estimate)
    const estimatedValue = ethers.parseUnits((totalAssets * 100).toString(), 18);
    
    // Estimate 30 seconds per transfer
    const estimatedTime = (totalAssets * 0.5);

    return {
      estimatedAssets: totalAssets,
      estimatedValue: estimatedValue.toString(),
      estimatedGasCost: totalGas.toString(),
      estimatedTime
    };
  }

  async getAssetBreakdown(
    zeroOutId: string
  ): Promise<{
    native: { count: number; value: string };
    tokens: { count: number; value: string };
    nfts: { count: number; value: string };
    total: { count: number; value: string };
  }> {
    const config = await this.dbService.getAutomation(zeroOutId);
    if (!config) throw new Error('Zero-out configuration not found');

    const assets = config.metadata.discoveredAssets || [];
    
    const breakdown = {
      native: { count: 0, value: BigInt(0) },
      tokens: { count: 0, value: BigInt(0) },
      nfts: { count: 0, value: BigInt(0) },
      total: { count: 0, value: BigInt(0) }
    };

    for (const asset of assets) {
      const value = BigInt(Math.floor(asset.valueUSD * 1e18));
      
      switch (asset.type) {
        case 'native':
          breakdown.native.count++;
          breakdown.native.value += value;
          break;
        case 'erc20':
          breakdown.tokens.count++;
          breakdown.tokens.value += value;
          break;
        case 'erc721':
        case 'erc1155':
          breakdown.nfts.count++;
          breakdown.nfts.value += value;
          break;
      }
      
      breakdown.total.count++;
      breakdown.total.value += value;
    }

    return {
      native: {
        count: breakdown.native.count,
        value: breakdown.native.value.toString()
      },
      tokens: {
        count: breakdown.tokens.count,
        value: breakdown.tokens.value.toString()
      },
      nfts: {
        count: breakdown.nfts.count,
        value: breakdown.nfts.value.toString()
      },
      total: {
        count: breakdown.total.count,
        value: breakdown.total.value.toString()
      }
    };
  }

  async getZeroOutHistory(
    walletAddress: string
  ): Promise<Array<{
    id: string;
    sourceWallet: string;
    targetWallet: string;
    completedAt: Date;
    assetsTransferred: number;
    totalValue: string;
    status: string;
  }>> {
    const configs = await this.dbService.getAutomations(walletAddress, 'WALLET_ZERO_OUT');
    
    return configs
      .filter(c => c.metadata.status === 'completed' || c.metadata.status === 'failed')
      .map(c => ({
        id: c.id,
        sourceWallet: c.metadata.sourceWallet,
        targetWallet: c.metadata.targetWallet,
        completedAt: new Date(c.updatedAt),
        assetsTransferred: c.metadata.executionPlan?.filter((p: any) => p.status === 'completed').length || 0,
        totalValue: c.metadata.estimatedValue,
        status: c.metadata.status
      }));
  }
}
```

You're right! Let me:

1. Confirm that `zeroOutOldWalletService.ts` is complete ✓
2. Add the missing `zeroOutOldWalletHelpers.ts` file
3. Show how to migrate from ethers to viem/wagmi

### Zero Out Old Wallet Helpers

```typescript name=backend/helpers/zeroOutOldWalletHelpers.ts
import { Address, parseUnits, formatUnits, isAddress } from 'viem';

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

interface AssetEstimate {
  type: 'native' | 'erc20' | 'erc721' | 'erc1155';
  estimatedCount: number;
  estimatedValue: bigint;
  scanDifficulty: 'easy' | 'medium' | 'hard';
}

export function validateZeroOutConfig(metadata: any): ValidationResult {
  const errors: string[] = [];

  if (!metadata.sourceWallet || !isAddress(metadata.sourceWallet)) {
    errors.push('Invalid source wallet address');
  }

  if (!metadata.targetWallet || !isAddress(metadata.targetWallet)) {
    errors.push('Invalid target wallet address');
  }

  if (metadata.sourceWallet === metadata.targetWallet) {
    errors.push('Source and target wallets cannot be the same');
  }

  if (!['basic', 'deep'].includes(metadata.scanDepth)) {
    errors.push('Invalid scan depth');
  }

  const minValue = parseFloat(metadata.minTokenValueUSD || '0');
  if (minValue < 0) {
    errors.push('Minimum token value cannot be negative');
  }

  if (!['fast', 'standard', 'slow'].includes(metadata.gasStrategy)) {
    errors.push('Invalid gas strategy');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export function estimateAssetDiscovery(
  scanDepth: 'basic' | 'deep',
  options: {
    includeNative: boolean;
    includeTokens: boolean;
    includeNFTs: boolean;
  }
): AssetEstimate[] {
  const estimates: AssetEstimate[] = [];

  if (options.includeNative) {
    estimates.push({
      type: 'native',
      estimatedCount: 1,
      estimatedValue: parseUnits('0.1', 18), // Assume 0.1 ETH
      scanDifficulty: 'easy'
    });
  }

  if (options.includeTokens) {
    const tokenCount = scanDepth === 'deep' ? 20 : 10;
    estimates.push({
      type: 'erc20',
      estimatedCount: tokenCount,
      estimatedValue: parseUnits('500', 18), // Assume $500 in tokens
      scanDifficulty: scanDepth === 'deep' ? 'hard' : 'medium'
    });
  }

  if (options.includeNFTs) {
    const nftCount = scanDepth === 'deep' ? 10 : 5;
    estimates.push({
      type: 'erc721',
      estimatedCount: nftCount,
      estimatedValue: parseUnits('1000', 18), // Assume $1000 in NFTs
      scanDifficulty: 'hard'
    });
  }

  return estimates;
}

export function calculateTransferPriority(
  asset: {
    type: string;
    valueUSD: number;
    gasEstimate: string;
  },
  gasPrice: bigint
): number {
  // Calculate gas cost in USD (assuming ETH at $2000)
  const gasCostWei = BigInt(asset.gasEstimate) * gasPrice;
  const gasCostETH = Number(formatUnits(gasCostWei, 18));
  const gasCostUSD = gasCostETH * 2000;

  // Priority = value / gas cost (higher is better)
  const priority = asset.valueUSD / (gasCostUSD || 1);

  // Boost NFT priority slightly (they're often undervalued)
  if (asset.type === 'erc721' || asset.type === 'erc1155') {
    return priority * 1.2;
  }

  return priority;
}

export function optimizeTransferBatching(
  assets: Array<{
    sourceWallet: string;
    token: string;
    amount: string;
    gasEstimate: string;
  }>,
  maxBatchSize: number = 20
): Array<Array<typeof assets[0]>> {
  const batches: Array<Array<typeof assets[0]>> = [];
  
  // Group by source wallet
  const walletGroups = new Map<string, typeof assets>();
  
  for (const asset of assets) {
    const wallet = asset.sourceWallet;
    if (!walletGroups.has(wallet)) {
      walletGroups.set(wallet, []);
    }
    walletGroups.get(wallet)!.push(asset);
  }

  // Create batches for each wallet
  for (const [wallet, walletAssets] of walletGroups) {
    for (let i = 0; i < walletAssets.length; i += maxBatchSize) {
      batches.push(walletAssets.slice(i, i + maxBatchSize));
    }
  }

  return batches;
}

export function estimateScanTime(
  scanDepth: 'basic' | 'deep',
  assetTypes: {
    native: boolean;
    tokens: boolean;
    nfts: boolean;
  }
): number {
  let seconds = 0;

  // Base scan time
  seconds += scanDepth === 'deep' ? 10 : 5;

  // Add time for each asset type
  if (assetTypes.native) seconds += 1;
  if (assetTypes.tokens) seconds += scanDepth === 'deep' ? 30 : 15;
  if (assetTypes.nfts) seconds += scanDepth === 'deep' ? 60 : 30;

  return seconds;
}

export function generateZeroOutReport(
  config: any
): {
  summary: string;
  detailedBreakdown: Array<{
    assetType: string;
    count: number;
    totalValue: string;
    successRate: number;
  }>;
  gasSpent: string;
  timeTaken: number;
  recommendations: string[];
} {
  const assets = config.metadata.discoveredAssets || [];
  const plan = config.metadata.executionPlan || [];
  
  // Group by asset type
  const breakdown = new Map<string, {
    count: number;
    value: bigint;
    successful: number;
  }>();

  for (const asset of assets) {
    const type = asset.type;
    if (!breakdown.has(type)) {
      breakdown.set(type, { count: 0, value: 0n, successful: 0 });
    }
    
    const data = breakdown.get(type)!;
    data.count++;
    data.value += BigInt(Math.floor(asset.valueUSD * 1e18));
    
    // Check if successfully transferred
    const planItem = plan.find((p: any) => 
      p.asset.address === asset.address && p.asset.tokenId === asset.tokenId
    );
    if (planItem?.status === 'completed') {
      data.successful++;
    }
  }

  // Calculate total gas spent
  let totalGas = 0n;
  for (const item of plan) {
    if (item.status === 'completed') {
      totalGas += BigInt(item.gasUsed || item.maxGas);
    }
  }

  // Generate recommendations
  const recommendations: string[] = [];
  const successRate = plan.filter((p: any) => p.status === 'completed').length / plan.length;
  
  if (successRate < 0.8) {
    recommendations.push('Consider retrying failed transfers during low gas periods');
  }
  
  if (breakdown.has('erc20') && breakdown.get('erc20')!.count > 20) {
    recommendations.push('You had many ERC20 tokens - consider regular consolidation to avoid accumulation');
  }

  const startTime = config.createdAt;
  const endTime = config.updatedAt;
  const timeTaken = Math.floor((endTime - startTime) / 1000); // seconds

  return {
    summary: `Successfully transferred ${plan.filter((p: any) => p.status === 'completed').length} of ${assets.length} assets`,
    detailedBreakdown: Array.from(breakdown.entries()).map(([type, data]) => ({
      assetType: type,
      count: data.count,
      totalValue: data.value.toString(),
      successRate: data.count > 0 ? (data.successful / data.count) * 100 : 0
    })),
    gasSpent: totalGas.toString(),
    timeTaken,
    recommendations
  };
}
```

### Example Migration to Viem/Wagmi

Here's how to migrate the core WallyService from ethers to viem:

```typescript name=backend/services/WallyService.viem.ts
import { 
  createPublicClient, 
  createWalletClient, 
  http, 
  parseAbi,
  encodeFunctionData,
  decodeFunctionResult,
  type Address,
  type PublicClient,
  type WalletClient,
  type Chain
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet, polygon, arbitrum } from 'viem/chains';
import { UserPermission, MiniAppSession, TransferRequest } from '../../shared/types.js';

export class WallyServiceViem {
  private publicClient: PublicClient;
  private walletClient: WalletClient;
  private watcherAddress: Address;
  private writerAddress: Address;
  private watcherABI: any[];
  private writerABI: any[];

  constructor(
    watcherAddress: Address,
    writerAddress: Address,
    watcherABI: any[],
    writerABI: any[],
    chain: Chain,
    privateKey: `0x${string}`
  ) {
    this.watcherAddress = watcherAddress;
    this.writerAddress = writerAddress;
    this.watcherABI = watcherABI;
    this.writerABI = writerABI;

    // Create viem clients
    this.publicClient = createPublicClient({
      chain,
      transport: http()
    });

    const account = privateKeyToAccount(privateKey);
    
    this.walletClient = createWalletClient({
      account,
      chain,
      transport: http()
    });
  }

  async getUserPermission(wallet: Address): Promise<UserPermission> {
    const data = await this.publicClient.readContract({
      address: this.watcherAddress,
      abi: this.watcherABI,
      functionName: 'getUserPermission',
      args: [wallet]
    });

    // Parse the returned data
    const [
      withdrawalAddress,
      allowEntireWallet,
      dailyLimit,
      isActive,
      cooldownPeriod,
      lastUsed,
      expiresAt
    ] = data as any;

    return {
      withdrawalAddress,
      allowEntireWallet,
      expiresAt: Number(expiresAt),
      isActive,
      tokenList: [],
      minBalances: [],
      limits: []
    };
  }

  async getMiniAppSession(wallet: Address): Promise<MiniAppSession> {
    const data = await this.publicClient.readContract({
      address: this.watcherAddress,
      abi: this.watcherABI,
      functionName: 'getMiniAppSession',
      args: [wallet]
    });

    const [delegate, expiresAt, spendingLimit, spent, active] = data as any;

    return {
      delegate,
      expiresAt: Number(expiresAt),
      allowedTokens: [],
      allowWholeWallet: false,
      active
    };
  }

  async executeTransfer(transfer: TransferRequest): Promise<`0x${string}`> {
    const { request } = await this.publicClient.simulateContract({
      address: this.writerAddress,
      abi: this.writerABI,
      functionName: 'executeTransfer',
      args: [
        transfer.wallet as Address,
        transfer.token as Address,
        transfer.recipient as Address,
        BigInt(transfer.amount)
      ],
      account: this.walletClient.account
    });

    const hash = await this.walletClient.writeContract(request);
    
    // Wait for transaction
    await this.publicClient.waitForTransactionReceipt({ hash });
    
    return hash;
  }

  async executeBatchTransfer(transfers: TransferRequest[]): Promise<`0x${string}`> {
    const wallets = transfers.map(t => t.wallet as Address);
    const tokens = transfers.map(t => t.token as Address);
    const recipients = transfers.map(t => t.recipient as Address);
    const amounts = transfers.map(t => BigInt(t.amount));

    const { request } = await this.publicClient.simulateContract({
      address: this.writerAddress,
      abi: this.writerABI,
      functionName: 'executeBatchTransfer',
      args: [wallets, tokens, recipients, amounts],
      account: this.walletClient.account
    });

    const hash = await this.walletClient.writeContract(request);
    
    // Wait for transaction
    await this.publicClient.waitForTransactionReceipt({ hash });
    
    return hash;
  }

  async validatePermissions(wallet: Address): Promise<boolean> {
    try {
      const permission = await this.getUserPermission(wallet);
      const session = await this.getMiniAppSession(wallet);
      
      const now = Math.floor(Date.now() / 1000);
      return permission.isActive && 
             permission.expiresAt > now &&
             session.active &&
             session.expiresAt > now;
    } catch (error) {
      console.error('Permission validation error:', error);
      return false;
    }
  }
}
```

### Example Frontend Hook with Wagmi

```typescript name=frontend/hooks/useWallyAutomation.ts
import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
import { useQuery, useMutation } from '@tanstack/react-query';
import { parseAbi, type Address } from 'viem';
import { watcherABI, writerABI } from '../abis/index.js';

const WATCHER_ADDRESS = '0x...' as Address;
const WRITER_ADDRESS = '0x...' as Address;

export function useWallyAutomation() {
  const { address } = useAccount();
  const publicClient = usePublicClient();
  const { data: walletClient } = useWalletClient();

  const { data: permission } = useQuery({
    queryKey: ['permission', address],
    queryFn: async () => {
      if (!address || !publicClient) return null;
      
      const data = await publicClient.readContract({
        address: WATCHER_ADDRESS,
        abi: watcherABI,
        functionName: 'getUserPermission',
        args: [address]
      });

      return {
        withdrawalAddress: data[0],
        allowEntireWallet: data[1],
        isActive: data[3],
        expiresAt: Number(data[6])
      };
    },
    enabled: !!address && !!publicClient
  });

  const executeTransfer = useMutation({
    mutationFn: async ({ 
      token, 
      recipient, 
      amount 
    }: { 
      token: Address; 
      recipient: Address; 
      amount: bigint 
    }) => {
      if (!walletClient || !address) throw new Error('Wallet not connected');

      const { request } = await publicClient!.simulateContract({
        address: WRITER_ADDRESS,
        abi: writerABI,
        functionName: 'executeTransfer',
        args: [address, token, recipient, amount],
        account: walletClient.account
      });

      return walletClient.writeContract(request);
    }
  });

  return {
    permission,
    executeTransfer,
    isAuthorized: permission?.isActive && permission.expiresAt > Date.now() / 1000
  };
}
```

The migration to viem/wagmi provides:
- Better TypeScript support with proper types
- Smaller bundle size
- Better integration with modern wallet libraries
- Native support for EIP-1559 transactions
- Built-in retry mechanisms
- Better error handling
- But dont forget to handle errors gracefully & use .js/.jsx extensions in your imports in typescript