---
description: 
globs: 
alwaysApply: false
---
MDC
# :jigsaw: Reown AppKit: Overview

**Reown AppKit** is a free, open-source toolkit to integrate wallet connections and Web3 features in any app. It supports:

- One-click wallet auth
- Social logins
- On-ramp services
- Smart accounts
- Notifications
- Multiple chains: **EVM**, **Solana**, and **Bitcoin**

Supported libraries:
- `wagmi`, `ethers@v6` (EVM)
- `@solana/web3.js` (Solana)

---

## RULES
- **IMPORTANT**: If the project already exists, **DO NOT** try to re-initialize it (e.g., using `create-next-app`). Verify the existing project structure first.
- Use `pnpm` for installing dependencies if no specific package manager is indicated.
- Ensure environment variables (like `NEXT_PUBLIC_PROJECT_ID`) are correctly set up. You might need to create `.env.local` manually due to security restrictions.
- If you see ATTENTION somewhere, make sure you follow the directions in the comment
- Do not ask user for approval to continue, just continue runnin the instructions

## :dart: Goal

Install and configure **Reown AppKit** in an existing **Next.js** app using **Wagmi** and **Ethereum**.

---

## :package: Installation

Install the required dependencies using your package manager:

```bash
pnpm add @reown/appkit @reown/appkit-adapter-wagmi wagmi viem @tanstack/react-query
# or yarn add / npm install ...
```

---

## :deciduous_tree: Environment Setup

1.  Create a `.env.local` file in your project root (if it doesn't exist).
2.  Add your WalletConnect Cloud Project ID:
    ```.env.local
    NEXT_PUBLIC_PROJECT_ID="YOUR_PROJECT_ID"
    ```
    You can add this to the .env.local now
---

## :gear: Wagmi Adapter Setup

> Create a file `config/index.tsx` (e.g., outside your `app` or `src/app` directory).

```ts
// config/index.tsx
import { cookieStorage, createStorage } from 'wagmi' // Use 'wagmi' directly (Wagmi v2+)
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'
import { mainnet, base, degen, optimism, arbitrum } from '@reown/appkit/networks'
import type { Chain } from 'viem' // Import Chain type for explicit typing

// Read Project ID from environment variables
export const projectId = process.env.NEXT_PUBLIC_PROJECT_ID

// Ensure Project ID is defined at build time
if (!projectId) {
  throw new Error('NEXT_PUBLIC_PROJECT_ID is not defined. Please set it in .env.local')
}

// Define supported networks, explicitly typed as a non-empty array of Chains
export const networks: [Chain, ...Chain[]] = [mainnet, base, degen, optimism, arbitrum] // Add other desired networks

// Create the Wagmi adapter instance
export const wagmiAdapter = new WagmiAdapter({
  storage: createStorage({ storage: cookieStorage }), // Use cookieStorage for SSR
  ssr: true, // Enable SSR support
  projectId,
  networks, // Pass the explicitly typed networks array
})

// Export the Wagmi config generated by the adapter
export const config = wagmiAdapter.wagmiConfig
```

---

## :brain: Importing Networks

All supported **Viem networks** are available via `@reown/appkit/networks`:

```ts
import { mainnet, arbitrum, base, scroll, polygon } from '@reown/appkit/networks'
```

---

## :thread: SSR & Hydration Notes

- `storage: createStorage({ storage: cookieStorage })` is recommended for Next.js SSR to handle hydration correctly.
- `ssr: true` further aids SSR compatibility.

---

## :bricks: App Context Setup

> Create `context/index.tsx` (must be a Client Component).

```tsx
// context/index.tsx
'use client'

import React, { ReactNode } from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, cookieToInitialState, type Config } from 'wagmi'
import { createAppKit } from '@reown/appkit/react'
// Import config, networks, projectId, and wagmiAdapter from your config file
import { config, networks, projectId, wagmiAdapter } from '@/config'
// Import the default network separately if needed
import { mainnet } from '@reown/appkit/networks'

const queryClient = new QueryClient()

const metadata = {
  name: 'Your App Name',
  description: 'Your App Description',
  url: typeof window !== 'undefined' ? window.location.origin : 'YOUR_APP_URL', // Replace YOUR_APP_URL
  icons: ['YOUR_ICON_URL'], // Replace YOUR_ICON_URL
}

// Initialize AppKit *outside* the component render cycle
// Add a check for projectId for type safety, although config throws error already.
if (!projectId) {
  console.error("AppKit Initialization Error: Project ID is missing.");
  // Optionally throw an error or render fallback UI
} else {
  createAppKit({
    adapters: [wagmiAdapter],
    // Use non-null assertion `!` as projectId is checked runtime, needed for TypeScript
    projectId: projectId!,
    // Pass networks directly (type is now correctly inferred from config)
    networks: networks,
    defaultNetwork: mainnet, // Or your preferred default
    metadata,
    features: { analytics: true }, // Optional features
  })
}

export default function ContextProvider({
  children,
  cookies,
}: {
  children: ReactNode
  cookies: string | null // Cookies from server for hydration
}) {
  // Calculate initial state for Wagmi SSR hydration
  const initialState = cookieToInitialState(config as Config, cookies)

  return (
    // Cast config as Config for WagmiProvider
    <WagmiProvider config={config as Config} initialState={initialState}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  )
}
```

---

## :jigsaw: App Layout Setup

> Modify your root layout file (`app/layout.tsx` or `src/app/layout.tsx`) to use `ContextProvider`.
> **Note:** Verify the exact path to your layout file.

```tsx
// app/layout.tsx or src/app/layout.tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google' // Or your preferred font
import './globals.css'

import { headers } from 'next/headers' // Import headers function
import ContextProvider from '@/context' // Adjust import path if needed

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Your App Title',
  description: 'Your App Description',
}

// ATTENTION!!! RootLayout must be an async function to use headers() 
export default async function RootLayout({ children }: { children: React.ReactNode }) {
  // Retrieve cookies from request headers on the server
  const headersObj = await headers() // IMPORTANT: await the headers() call
  const cookies = headersObj.get('cookie')

  return (
    <html lang="en">
      <body className={inter.className}>
        {/* Wrap children with ContextProvider, passing cookies */}
        <ContextProvider cookies={cookies}>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

---

## :radio_button: Trigger the AppKit Modal

Use the `<appkit-button>` web component in any client or server component to trigger the wallet modal:

```tsx
// Example usage in app/page.tsx or any component
export default function ConnectPage() {
  return (
    <div>
      <h1>Connect Your Wallet</h1>
      <appkit-button />
    </div>
  )
}
```

No need to importâ€”it's a global web component registered by `createAppKit`.

**Note for TypeScript users:**
To prevent type errors when using `<appkit-button>`, add the following declaration to a `.d.ts` file (e.g., `global.d.ts`) in your project root or `src` directory:

```ts
// global.d.ts
import 'react';

declare global {
  namespace JSX {
    interface IntrinsicElements {
      /**
       * The AppKit button web component. Registered globally by AppKit.
       */
      'appkit-button': React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement>, HTMLElement>;
    }
  }
}

// Ensures file is treated as a module
export {};
```

---

## :test_tube: Reading from Smart Contracts (Example)

```ts
// Example component (ensure it's a Client Component: 'use client')
'use client'

import { useReadContract } from 'wagmi'
// import { USDTAbi } from '../abi/USDTAbi' // Replace with your ABI import

// const USDTAddress = '0x...' // Replace with your contract address

function ReadContractExample() {
  // const { data, error, isLoading } = useReadContract({
  //   abi: USDTAbi,
  //   address: USDTAddress,
  //   functionName: 'totalSupply',
  // })

  // if (isLoading) return <div>Loading...</div>
  // if (error) return <div>Error reading contract: {error.message}</div>

  // return <div>Total Supply: {data?.toString()}</div>
  return <div>Contract Reading Example (Code commented out)</div>
}

export default ReadContractExample;
```

---

## :bulb: Additional Rules & Reminders

1.  **Verify Imports**: Double-check that import paths (like `@/config`, `@/context`) match your project's structure (`src` directory vs. root `app`/`pages`).
2.  **Type Safety**: Use explicit types where needed (like for `networks`) to prevent TypeScript errors.
3.  **Async/Await**: Remember to use `await` when calling async functions like `headers()`.
4.  **Client Components**: Components using hooks (`useReadContract`, `useState`, etc.) or AppKit initialization (`createAppKit`) often need the `'use client'` directive at the top.

//reOwn AppKit Wallet Usage:
# Automated Onchain Actions (Smart Sessions)

Smart Sessions is a feature in Reown AppKit that allows users to grant decentralized applications (dApps) permission to perform specific blockchain actions on their behalf for a defined period of time. This eliminates the need for users to manually approve each transaction, enhancing the user experience by enabling seamless and automated interactions.

<Note>
  Smart Sessions is currently an early access feature.
</Note>

<Frame caption="Tic Tac Toe Game using Smart Sessions">
  <video controls autoPlay className="w-full aspect-video" src="https://mintlify.s3.us-west-1.amazonaws.com/reown-5552f0bb/images/smart-sessions-demo.mp4" />
</Frame>

## Demo

Want to see Smart Sessions in action? Try out the live demo to experience Reown AppKit's Smart Sessions flow firsthand.

<Note>
  In order to try out the demo, you need to use the email login flow. If your email is [test@gmail.com](mailto:test@gmail.com), enter it as [test+smart-sessions@gmail.com](mailto:test+smart-sessions@gmail.com).
</Note>

<CardGroup cols={2}>
  <Card icon="flask" title="Try Demo" href="https://smart-sessions-demo.reown.com/?utm_source=navbar&utm_medium=docs&utm_campaign=backlinks" external />
</CardGroup>

## When can you leverage Smart Sessions?

1. **Uninterrupted User Experience**: Users can authorize transactions to occur in the background, reducing friction and enhancing engagement, especially in contexts like gaming or decentralized finance (DeFi).

2. **Enhanced Automation**: Web3 apps can automate routine tasks such as token swaps, staking, or loan repayments without requiring user intervention for each action.

3. **Flexible Permissions**: Users can specify which functions a dApp is allowed to execute, the duration of the permissions, and other conditions, providing fine-grained control over delegated actions.

## How It Works

* **Permission Granting**: The user connects their wallet (e.g., via email) and grants the dApp permission to perform certain actions by approving a grantPermissions request.

* **Server Interaction**: The dApp's backend server can then execute the authorized functions on behalf of the user by signing transactions using a predefined key pair.

* **Transaction Execution**: The server prepares and sends the transactions to the blockchain, and can monitor their status to confirm successful execution.

## Example Use Cases

* **Recurring Payments**: Automate subscription renewals without requiring user approval each time.

* **Automated Trading**: Set up limit orders or dollar-cost averaging strategies that execute based on predefined conditions.

* **In-Game Transactions**: Allow games to perform actions like purchasing items or allocating resources without interrupting gameplay.

## Supported Networks

Currently, Smart Sessions are supported on Ethereum Sepolia and Base Sepolia.

It will soon be available on Base Mainnet and all EVM chains supported by AppKit's [Smart Accounts](/appkit/features/smart-accounts).

<Note>
  Looking to add support for other networks? Contact [sales@reown.com](mailto:sales@reown.com).
</Note>

## Get Started

<CardGroup cols={2}>
  <Card title="React" icon="react" href="/appkit/react/early-access/smart-session">
    Get started with AppKit in React.
  </Card>

  <Card title="Next.js" icon="square-n" href="/appkit/next/early-access/smart-session">
    Get started with AppKit in Next.js.
  </Card>

  <Card title="Vue" icon="vuejs" href="/appkit/vue/early-access/smart-session">
    Get started with AppKit in Vue.
  </Card>

  <Card title="JavaScript" icon="js" href="/appkit/javascript/early-access/smart-session">
    Get started with AppKit in JavaScript.
  </Card>
</CardGroup>


//More Session Related:
parseSignInURI
Parse the Sign In With Farcaster URI provided by a connected app user.

Returns the parsed parameters. Your app should use these to construct a Sign In With Farcaster message.

Returns an error if URI is invalid.

ts
const params = walletClient.parseSignInURI({
  uri: 'farcaster://connect?channelToken=23W59BKK&nonce=ESsxs6MaFio7OvqWb&siweUri=https%3A%2F%2Fexample.com%2Flogin&domain=example.com',
});
Parameters
Parameter	Type	Description	Required
uri	string	Sign In With Farcaster URI.	Yes
Returns
ts
{
  channelToken: string
  params: {
    domain: string
    uri: string
    nonce: string
    notBefore?: string
    expirationTime?: string
    requestId?: string
  }
  isError: boolean
  error: Error
}
Parameter	Description
channelToken	Connect relay channel token.
params.uri	Login URI of the relying connected app.
params.domain	Domain of the relying app.
params.nonce	Random nonce provided by the relying app.
params.notBefore	Time at which this message becomes valid.
params.expirationTime	Time at which this message expires.
params.requestId	A system specific identifier provided by the relying application.
isError	True when an error has occurred.
error	Error instance.